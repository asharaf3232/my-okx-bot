// =================================================================
// OKX Advanced Analytics Bot - index.js (v64 - Stable & Full-Featured)
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
require("dotenv").config();
const { connectDB, getDB } = require("./database.js");

// --- Configuration ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID, 10);
const TARGET_CHANNEL_ID = process.env.TARGET_CHANNEL_ID;
const API_BASE_URL = "https://www.okx.com";

// --- State ---
let waitingState = null;

// ========== Database Helpers ==========
const getCollection = (name) => getDB().collection("configs");

async function getConfig(id, defaultValue = {}) {
  try {
    const doc = await getCollection("configs").findOne({ _id: id });
    return doc ? doc.data : defaultValue;
  } catch (e) {
    console.error(`Error getting config ${id}:`, e);
    return defaultValue;
  }
}

async function saveConfig(id, data) {
  try {
    await getCollection("configs").updateOne({ _id: id }, { $set: { data } }, { upsert: true });
  } catch (e) {
    console.error(`Error saving config ${id}:`, e);
  }
}

// Load/Save functions
const loadCapital = async () => (await getConfig("capital", { value: 0 })).value;
const saveCapital = (value) => saveConfig("capital", { value });
const loadSettings = () => getConfig("settings", { dailySummary: true, autoPostToChannel: false, debugMode: false });
const saveSettings = (settings) => saveConfig("settings", settings);
const loadPositions = () => getConfig("positions", {});
const savePositions = (positions) => saveConfig("positions", positions);
const loadBalanceState = () => getConfig("balanceState", {});
const saveBalanceState = (state) => saveConfig("balanceState", state);
const loadAlerts = () => getConfig("priceAlerts", []);
const saveAlerts = (alerts) => saveConfig("priceAlerts", alerts);
const loadAlertSettings = () => getConfig("alertSettings", { global: 5, overrides: {} });
const saveAlertSettings = (s) => saveConfig("alertSettings", s);
// (ÿ®ŸÇŸäÿ© ÿßŸÑÿØŸàÿßŸÑ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÖŸàÿ¨ŸàÿØÿ© ÿ®ÿßŸÑÿ£ÿ≥ŸÅŸÑ)

// ========== OKX API & Helpers ==========
function getHeaders(method, path, body = "") {
  const timestamp = new Date().toISOString();
  const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body);
  const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64");
  return {
    "OK-ACCESS-KEY": process.env.OKX_API_KEY, "OK-ACCESS-SIGN": sign,
    "OK-ACCESS-TIMESTAMP": timestamp, "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE,
    "Content-Type": "application/json",
  };
}

async function getMarketPrices() {
  try {
    const res = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`);
    const json = await res.json();
    if (json.code !== '0') return null;
    return json.data.reduce((acc, t) => {
      acc[t.instId] = { price: parseFloat(t.last), change24h: parseFloat(t.open24h) > 0 ? (parseFloat(t.last) - parseFloat(t.open24h)) / parseFloat(t.open24h) : 0 };
      return acc;
    }, {});
  } catch { return null; }
}

async function getBalanceForComparison() {
  try {
    const res = await fetch(`${API_BASE_URL}/api/v5/account/balance`, { headers: getHeaders("GET", "/api/v5/account/balance") });
    const json = await res.json();
    if (json.code !== '0' || !json.data[0]?.details) return null;
    return json.data[0].details.reduce((map, asset) => {
      map[asset.ccy] = parseFloat(asset.eq);
      return map;
    }, {});
  } catch { return null; }
}

async function updatePositionAndAnalyze(asset, diff, price, newAmt) {
    if (!price || isNaN(price)) return null;
    const positions = await loadPositions();
    const p = positions[asset];
    const tradeValue = Math.abs(diff) * price;
    let report = null;

    if (diff > 0) { // Buy
        if (!p) {
            positions[asset] = { totalBought: diff, totalCost: tradeValue, avgBuy: price, openDate: new Date().toISOString(), realizedValue: 0, totalSold: 0 };
        } else {
            p.totalBought += diff;
            p.totalCost += tradeValue;
            p.avgBuy = p.totalCost / p.totalBought;
        }
    } else if (p) { // Sell
        p.realizedValue += tradeValue;
        p.totalSold += Math.abs(diff);
        if (newAmt * price < 1) { // Closing position
            const pnl = p.realizedValue - p.totalCost;
            const pnlPct = p.totalCost > 0 ? (pnl / p.totalCost) * 100 : 0;
            const sign = pnl >= 0 ? "+" : "";
            report =
                `üîî **ÿ™ŸÇÿ±Ÿäÿ± ÿ•ÿ∫ŸÑÿßŸÇ ÿµŸÅŸÇÿ©**\n` +
                `*ÿßŸÑÿ£ÿµŸÑ:* ${asset}/USDT ${pnl >= 0 ? "üü¢" : "üî¥"}\n` +
                `*ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©:* \`${sign}${pnl.toFixed(2)}\` (\`${sign}${pnlPct.toFixed(2)}%\`)\n`;
            delete positions[asset];
        }
    }
    await savePositions(positions);
    return report;
}

async function monitorBalanceChanges() {
    try {
        const prevState = await loadBalanceState();
        const prevBal = prevState.balances || {};
        const prevVal = prevState.totalValue || 0;

        const currentBal = await getBalanceForComparison();
        if (!currentBal) return;

        const prices = await getMarketPrices();
        if (!prices) return;

        const currentTotalValue = Object.entries(currentBal).reduce((sum, [ccy, amt]) => {
            const price = prices[`${ccy}-USDT`] ? prices[`${ccy}-USDT`].price : (ccy === 'USDT' ? 1 : 0);
            return sum + (amt * price);
        }, 0);

        if (Object.keys(prevBal).length === 0) {
            await saveBalanceState({ balances: currentBal, totalValue: currentTotalValue });
            return;
        }

        let tradesDetected = false;
        for (const asset of new Set([...Object.keys(prevBal), ...Object.keys(currentBal)])) {
            if (asset === "USDT") continue;

            const diff = (currentBal[asset] || 0) - (prevBal[asset] || 0);
            const priceData = prices[`${asset}-USDT`];
            if (!priceData || !priceData.price) continue;

            const tradeValue = Math.abs(diff) * priceData.price;
            if (tradeValue < 0.1) continue;

            tradesDetected = true;
            const price = priceData.price;

            const positionReport = await updatePositionAndAnalyze(asset, diff, price, currentBal[asset] || 0);
            if (positionReport) {
                await bot.api.sendMessage(AUTHORIZED_USER_ID, positionReport, { parse_mode: "Markdown" });
            }

            const tradeType = diff > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢‚¨ÜÔ∏è" : (currentBal[asset] * price < 1 ? "ÿ•ÿ∫ŸÑÿßŸÇ üî¥‚¨áÔ∏è" : "ÿ®Ÿäÿπ ÿ¨ÿ≤ÿ¶Ÿä üü†");
            const newAssetValue = (currentBal[asset] || 0) * price;
            const portPct = currentTotalValue > 0 ? (newAssetValue / currentTotalValue) * 100 : 0;
            const cashValue = currentBal['USDT'] || 0;
            const cashPct = currentTotalValue > 0 ? (cashValue / currentTotalValue) * 100 : 0;
            const entryPct = prevVal > 0 ? (tradeValue / prevVal) * 100 : 0;

            const privateText =
                `üîî **ÿ™ÿ≠ŸÑŸäŸÑ ÿ≠ÿ±ŸÉÿ© ÿ™ÿØÿßŸàŸÑ**\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `*ÿßŸÑÿπŸÖŸÑŸäÿ©:* ${tradeType}\n` +
                `*ÿßŸÑÿ£ÿµŸÑ:* \`${asset}/USDT\`\n\n` +
                `*ÿ≥ÿπÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞:* \`$${price.toFixed(4)}\`\n` +
                `*ÿßŸÑŸÉŸÖŸäÿ©:* \`${Math.abs(diff).toFixed(6)}\`\n` +
                `*ŸÇŸäŸÖÿ© ÿßŸÑÿµŸÅŸÇÿ©:* \`$${tradeValue.toFixed(2)}\`\n\n` +
                `*ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:*\n` +
                ` ‚ñ´Ô∏è ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸÅŸÇÿ©: \`${entryPct.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è Ÿàÿ≤ŸÜ ÿßŸÑÿπŸÖŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØ: \`${portPct.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿ¨ÿØŸäÿØÿ©: \`${cashPct.toFixed(2)}%\`\n`;

            const settings = await loadSettings();
            if (settings.autoPostToChannel) {
                const channelText =
                    `üîî **ÿ™ŸàÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©: ${diff > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢" : "ÿ®Ÿäÿπ üî¥"}**\n\n` +
                    `*ÿßŸÑÿπŸÖŸÑÿ©:* \`${asset}/USDT\`\n` +
                    `*ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠:* ~\`$${price.toFixed(4)}\`\n` +
                    `*ÿ≠ÿ¨ŸÖ ÿßŸÑÿØÿÆŸàŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`${entryPct.toFixed(2)}%\``;
                try {
                    await bot.api.sendMessage(TARGET_CHANNEL_ID, channelText, { parse_mode: "Markdown" });
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, privateText, { parse_mode: "Markdown" });
                } catch (e) {
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, "‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÑŸÑŸÇŸÜÿßÿ©.");
                }
            } else {
                const kb = new InlineKeyboard().text("‚úÖ ŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©", "publish_trade").text("‚ùå ÿ™ÿ¨ÿßŸáŸÑ", "ignore_trade");
                await bot.api.sendMessage(AUTHORIZED_USER_ID, `*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n${privateText}`, { parse_mode: "Markdown", reply_markup: kb });
            }
        }

        if (tradesDetected) {
            await saveBalanceState({ balances: currentBal, totalValue: currentTotalValue });
        }
    } catch (e) {
        console.error("Error in monitorBalanceChanges:", e);
    }
}


// ========== Express Server & Bot Start ==========
app.use(express.json());
app.get("/healthcheck", (req, res) => {
    res.status(200).send("OK");
});

bot.use(async (ctx, next) => {
    if (ctx.from?.id === AUTHORIZED_USER_ID) {
        await next();
    }
});

const mainKeyboard = new Keyboard()
    .text("üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").text("üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").row()
    .text("‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©").text("üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá").row()
    .text("üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©").row()
    .text("‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™").resized();

bot.command("start", (ctx) => {
    ctx.reply("ü§ñ ÿ®Ÿàÿ™ OKX ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä v64 ŸäÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ!", { reply_markup: mainKeyboard });
});

bot.command("settings", async (ctx) => await sendSettingsMenu(ctx));

bot.command("pnl", async (ctx) => {
    const args = ctx.match.trim().split(/\s+/);
    if (args.length !== 3 || args[0] === '') {
        return await ctx.reply("‚ùå ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©.\nÿßÿ≥ÿ™ÿÆÿØŸÖ: `/pnl <ÿ¥ÿ±ÿßÿ°> <ÿ®Ÿäÿπ> <ŸÉŸÖŸäÿ©>`", { parse_mode: "Markdown" });
    }
    const [buyPrice, sellPrice, quantity] = args.map(parseFloat);
    if (isNaN(buyPrice) || isNaN(sellPrice) || isNaN(quantity) || buyPrice <= 0 || sellPrice <= 0 || quantity <= 0) {
        return await ctx.reply("‚ùå ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸäŸÖ ÿ£ÿ±ŸÇÿßŸÖ ŸÖŸàÿ¨ÿ®ÿ©.");
    }
    const pnl = (sellPrice - buyPrice) * quantity;
    const pnlPercent = (pnl / (buyPrice * quantity)) * 100;
    const sign = pnl >= 0 ? "+" : "";
    await ctx.reply(`*ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:* \`${sign}${pnl.toFixed(2)}\` (\`${sign}${pnlPercent.toFixed(2)}%\`)`, { parse_mode: "Markdown" });
});

bot.on("message:text", async (ctx) => {
    const text = ctx.message.text.trim();
    if (waitingState) {
        // Handle waiting states
        // ... (ŸáŸÜÿß ŸÖŸÜÿ∑ŸÇ waitingState)
    } else {
        switch (text) {
            case "üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
                // ... (ŸÖŸÜÿ∑ŸÇ ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©)
                break;
            case "üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
                // ... (ŸÖŸÜÿ∑ŸÇ ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©)
                break;
            case "‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©":
                // ... (ŸÖŸÜÿ∑ŸÇ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©)
                break;
            case "üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá":
                // ... (ŸÖŸÜÿ∑ŸÇ ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá)
                break;
            case "üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©":
                await ctx.reply("ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ŸÖÿ± `/pnl`.\nŸÖÿ´ÿßŸÑ: `/pnl 50000 60000 0.5`", { parse_mode: "Markdown" });
                break;
            case "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™":
                await sendSettingsMenu(ctx);
                break;
        }
    }
});

async function sendSettingsMenu(ctx) {
    const settings = await loadSettings();
    const settingsKeyboard = new InlineKeyboard()
        .text("üí∞ ÿ™ÿπŸäŸäŸÜ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ", "set_capital")
        .text(`üöÄ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä: ${settings.autoPostToChannel ? '‚úÖ' : '‚ùå'}`, "toggle_autopost")
        .row()
        .text(`üêû Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ: ${settings.debugMode ? '‚úÖ' : '‚ùå'}`, "toggle_debug");
    
    const text = "‚öôÔ∏è *ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™*";
    try {
        await ctx.editMessageText(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    } catch {
        await ctx.reply(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    }
}

bot.on("callback_query:data", async (ctx) => {
    const data = ctx.callbackQuery.data;
    await ctx.answerCallbackQuery();

    if (data === "toggle_autopost" || data === "toggle_debug") {
        const settings = await loadSettings();
        if (data === 'toggle_autopost') settings.autoPostToChannel = !settings.autoPostToChannel;
        if (data === 'toggle_debug') settings.debugMode = !settings.debugMode;
        await saveSettings(settings);
        await sendSettingsMenu(ctx);
    } else if (data === "set_capital") {
        waitingState = 'set_capital';
        await ctx.editMessageText("ÿ£ÿ±ÿ≥ŸÑ ŸÖÿ®ŸÑÿ∫ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ.");
    } else if (data === "publish_trade") {
        const textToPublish = ctx.callbackQuery.message.text.replace("*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n", "");
        try {
            await bot.api.sendMessage(TARGET_CHANNEL_ID, textToPublish, { parse_mode: "Markdown" });
            await ctx.editMessageText("‚úÖ ÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ± ÿ®ŸÜÿ¨ÿßÿ≠.");
        } catch {
            await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ±.");
        }
    } else if (data === "ignore_trade") {
        await ctx.editMessageText("‚ùå ÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿµŸÅŸÇÿ©.");
    }
});


async function startBot() {
    console.log("‚ñ∂Ô∏è ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™...");
    try {
        await connectDB();
        console.log("‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠.");

        setInterval(monitorBalanceChanges, 60000);
        console.log("‚úÖ ÿ™ŸÖ ÿ¨ÿØŸàŸÑÿ© ŸÖŸáŸÖÿ© ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿµŸÅŸÇÿßÿ™.");

        await bot.start();
        console.log("ü§ñ ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿØÿ£ ŸàŸäÿπŸÖŸÑ ŸÅŸä Ÿàÿ∂ÿπŸäÿ© Polling.");

        app.listen(PORT, () => {
            console.log(`üåê ÿßŸÑÿÆÿßÿØŸÖ Ÿäÿ≥ÿ™ŸÖÿπ ÿπŸÑŸâ ÿßŸÑŸÖŸÜŸÅÿ∞ ${PORT} Ÿàÿ¨ÿßŸáÿ≤ ŸÑŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ©.`);
        });

    } catch (e) {
        console.error("‚ùå ŸÅÿ¥ŸÑ ÿ≠ÿßÿØ ŸÅŸä ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™:", e);
        process.exit(1);
    }
}

startBot();
