// =================================================================
// OKX Advanced Analytics Bot - v67 (Stable & Full-Featured)
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
require("dotenv").config();
const { connectDB, getDB } = require("./database.js");

// --- Bot Setup ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID);
const TARGET_CHANNEL_ID = process.env.TARGET_CHANNEL_ID;
const API_BASE_URL = "https://www.okx.com";

// --- State Variables ---
let waitingState = null;

// === Database Functions ===
const getCollection = (collectionName) => getDB().collection("configs");

async function getConfig(id, defaultValue = {}) {
    try {
        const doc = await getCollection("configs").findOne({ _id: id });
        return doc ? doc.data : defaultValue;
    } catch (e) {
        console.error(`Error getting config ${id}:`, e);
        return defaultValue;
    }
}

async function saveConfig(id, data) {
    try {
        await getCollection("configs").updateOne({ _id: id }, { $set: { data: data } }, { upsert: true });
    } catch (e) {
        console.error(`Error saving config ${id}:`, e);
    }
}

const loadCapital = async () => (await getConfig("capital", { value: 0 })).value;
const saveCapital = (amount) => saveConfig("capital", { value: amount });
const loadSettings = () => getConfig("settings", { dailySummary: true, autoPostToChannel: false, debugMode: false });
const saveSettings = (settings) => saveConfig("settings", settings);
const loadPositions = () => getConfig("positions", {});
const savePositions = (positions) => saveConfig("positions", positions);
const loadHistory = () => getConfig("dailyHistory", []);
const saveHistory = (history) => saveConfig("dailyHistory", history);
const loadHourlyHistory = () => getConfig("hourlyHistory", []);
const saveHourlyHistory = (history) => saveConfig("hourlyHistory", history);
const loadBalanceState = () => getConfig("balanceState", {});
const saveBalanceState = (state) => saveConfig("balanceState", state);
const loadAlerts = () => getConfig("priceAlerts", []);
const saveAlerts = (alerts) => saveConfig("priceAlerts", alerts);
const loadAlertSettings = () => getConfig("alertSettings", { global: 5, overrides: {} });
const saveAlertSettings = (settings) => saveConfig("alertSettings", settings);
const loadPriceTracker = () => getConfig("priceTracker", { totalPortfolioValue: 0, assets: {} });
const savePriceTracker = (tracker) => saveConfig("priceTracker", tracker);

// === Helper & API Functions ===
async function sendDebugMessage(message) {
    const settings = await loadSettings();
    if (settings.debugMode) {
        try {
            await bot.api.sendMessage(AUTHORIZED_USER_ID, `üêû *Debug:* ${message}`, { parse_mode: "Markdown" });
        } catch (e) {
            console.error("Failed to send debug message:", e);
        }
    }
}

function getHeaders(method, path, body = "") {
    const timestamp = new Date().toISOString();
    const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body);
    const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64");
    return {
        "OK-ACCESS-KEY": process.env.OKX_API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE,
        "Content-Type": "application/json",
    };
}

async function getMarketPrices() {
    try {
        const tickersRes = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`);
        const tickersJson = await tickersRes.json();
        if (tickersJson.code !== '0') return null;
        const prices = {};
        tickersJson.data.forEach(t => {
            const lastPrice = parseFloat(t.last);
            const openPrice = parseFloat(t.open24h);
            const change24h = openPrice > 0 ? (lastPrice - openPrice) / openPrice : 0;
            prices[t.instId] = { price: lastPrice, open24h: openPrice, change24h: change24h };
        });
        return prices;
    } catch (error) { return null; }
}

async function getPortfolio(prices) {
    try {
        const path = "/api/v5/account/balance";
        const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) });
        const json = await res.json();
        if (json.code !== '0') return { error: `ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©: ${json.msg}` };
        
        let assets = [], total = 0;
        json.data[0]?.details?.forEach(asset => {
            const amount = parseFloat(asset.eq);
            if (amount > 0) {
                const instId = `${asset.ccy}-USDT`;
                const priceData = prices[instId] || { price: (asset.ccy === "USDT" ? 1 : 0), change24h: 0 };
                const value = amount * priceData.price;
                total += value;
                if (value >= 1) {
                    assets.push({ asset: asset.ccy, price: priceData.price, value, amount, change24h: priceData.change24h });
                }
            }
        });
        assets.sort((a, b) => b.value - a.value);
        return { assets, total };
    } catch (e) { return { error: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖŸÜÿµÿ©." }; }
}

async function getBalanceForComparison() {
    try {
        const path = "/api/v5/account/balance";
        const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) });
        const json = await res.json();
        if (json.code !== '0') return null;
        const balanceMap = {};
        json.data[0]?.details?.forEach(asset => {
            balanceMap[asset.ccy] = parseFloat(asset.eq);
        });
        return balanceMap;
    } catch (error) { return null; }
}

// ... (ÿ®ŸÇŸäÿ© ÿßŸÑÿØŸàÿßŸÑ ÿßŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÖÿ´ŸÑ getInstrumentDetails, createChartUrl, etc. ŸÉŸÖÿß ŸáŸä ŸÅŸä ŸÖŸÑŸÅŸÉ ÿßŸÑÿ£ÿµŸÑŸä)

async function updatePositionAndAnalyze(asset, amountChange, price, newTotalAmount) {
    if (!asset || isNaN(price)) return null;
    const positions = await loadPositions();
    const position = positions[asset];
    const tradeValue = Math.abs(amountChange) * price;
    let retrospectiveReport = null;
    
    if (amountChange > 0) { // Buy
        if (!position) {
            positions[asset] = { totalAmountBought: amountChange, totalCost: tradeValue, avgBuyPrice: price, openDate: new Date().toISOString(), totalAmountSold: 0, realizedValue: 0 };
        } else {
            position.totalAmountBought += amountChange;
            position.totalCost += tradeValue;
            position.avgBuyPrice = position.totalCost / position.totalAmountBought;
        }
    } else if (amountChange < 0 && position) { // Sell
        const amountSold = Math.abs(amountChange);
        position.realizedValue += tradeValue;
        position.totalAmountSold += amountSold;
        if (newTotalAmount * price < 1) { // Closing position
            const finalPnl = position.realizedValue - position.totalCost;
            const finalPnlPercent = (position.totalCost > 0) ? (finalPnl / position.totalCost) * 100 : 0;
            const pnlEmoji = finalPnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
            retrospectiveReport = `‚úÖ **ÿ™ŸÇÿ±Ÿäÿ± ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤: ${asset}**\n\n` +
                `*ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©:* ${pnlEmoji} \`${finalPnl >= 0 ? '+' : ''}${finalPnl.toFixed(2)}\` (\`${finalPnl >= 0 ? '+' : ''}${finalPnlPercent.toFixed(2)}%\`)\n`;
            delete positions[asset];
        }
    }
    await savePositions(positions);
    return retrospectiveReport;
}

// ======================= ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä ŸáŸÜÿß =======================
async function monitorBalanceChanges() {
    try {
        await sendDebugMessage("ÿ®ÿØÿ° ÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÅŸÇÿßÿ™...");
        let previousState = await loadBalanceState();
        let previousBalanceState = previousState.balances || {};
        let previousTotalPortfolioValue = previousState.totalValue || 0;
        
        const currentBalance = await getBalanceForComparison();
        if (!currentBalance) return;
        
        const prices = await getMarketPrices();
        if (!prices) return;

        const { total: newTotalPortfolioValue, assets: currentAssets, error } = await getPortfolio(prices);
        if (error) return;

        if (Object.keys(previousBalanceState).length === 0) {
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
            return;
        }

        const allAssets = new Set([...Object.keys(previousBalanceState), ...Object.keys(currentBalance)]);
        let tradesDetected = false;

        for (const asset of allAssets) {
            if (asset === 'USDT') continue;
            const prevAmount = previousBalanceState[asset] || 0;
            const currAmount = currentBalance[asset] || 0;
            const difference = currAmount - prevAmount;
            
            const priceData = prices[`${asset}-USDT`];
            if (!priceData || isNaN(priceData.price)) continue;
            
            const tradeValue = Math.abs(difference * priceData.price);
            if (tradeValue < 0.1) continue;

            tradesDetected = true;
            const price = priceData.price;
            const retrospectiveReport = await updatePositionAndAnalyze(asset, difference, price, currAmount);

            if (retrospectiveReport) {
                await bot.api.sendMessage(AUTHORIZED_USER_ID, retrospectiveReport, { parse_mode: "Markdown" });
            }

            const newAssetValue = currAmount * price;
            const portfolioPercentage = newTotalPortfolioValue > 0 ? (newAssetValue / newTotalPortfolioValue) * 100 : 0;
            const usdtAsset = currentAssets.find(a => a.asset === 'USDT') || { value: 0 };
            const newCashValue = usdtAsset.value;
            const newCashPercentage = newTotalPortfolioValue > 0 ? (newCashValue / newTotalPortfolioValue) * 100 : 0;
            const entryOfPortfolio = previousTotalPortfolioValue > 0 ? (tradeValue / previousTotalPortfolioValue) * 100 : 0;

            const tradeType = difference > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢‚¨ÜÔ∏è" : (currAmount * price < 1 ? "ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤ üî¥‚¨áÔ∏è" : "ÿ®Ÿäÿπ ÿ¨ÿ≤ÿ¶Ÿä üü†");

            // ÿ®ŸÜÿßÿ° ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÅÿµŸÑÿ© ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            const privateTradeAnalysisText = `üîî **ÿ™ÿ≠ŸÑŸäŸÑ ÿ≠ÿ±ŸÉÿ© ÿ™ÿØÿßŸàŸÑ**\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üî∏ **ÿßŸÑÿπŸÖŸÑŸäÿ©:** ${tradeType}\n` +
                `üî∏ **ÿßŸÑÿ£ÿµŸÑ:** \`${asset}/USDT\`\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµŸÅŸÇÿ©:**\n` +
                ` ‚ñ´Ô∏è *ÿ≥ÿπÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞:* \`$${price.toFixed(4)}\`\n` +
                ` ‚ñ´Ô∏è *ÿßŸÑŸÉŸÖŸäÿ©:* \`${Math.abs(difference).toFixed(6)}\`\n` +
                ` ‚ñ´Ô∏è *ŸÇŸäŸÖÿ© ÿßŸÑÿµŸÅŸÇÿ©:* \`$${tradeValue.toFixed(2)}\`\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` +
                ` ‚ñ´Ô∏è *ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸÅŸÇÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`${entryOfPortfolio.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è *ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿ¨ÿØŸäÿØÿ©:* \`${newCashPercentage.toFixed(2)}%\``;

            const settings = await loadSettings();
            if (settings.autoPostToChannel) {
                // ÿ®ŸÜÿßÿ° ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿÆÿ™ÿµÿ±ÿ© ŸÑŸÑŸÇŸÜÿßÿ©
                const channelText = `üîî **ÿ™ŸàÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©: ${difference > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢" : "ÿ®Ÿäÿπ üî¥"}**\n\n` +
                    `*ÿßŸÑÿπŸÖŸÑÿ©:* \`${asset}/USDT\`\n` +
                    `*ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ:* ~\`$${price.toFixed(4)}\`\n` +
                    `*ÿ≠ÿ¨ŸÖ ÿßŸÑÿØÿÆŸàŸÑ:* \`${entryOfPortfolio.toFixed(2)}%\` ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©\n` +
                    `*ÿ™ŸÖÿ´ŸÑ ÿßŸÑÿ¢ŸÜ:* \`${portfolioPercentage.toFixed(2)}%\` ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©`;
                
                try {
                    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖÿÆÿ™ÿµÿ±ÿ© ŸÑŸÑŸÇŸÜÿßÿ©
                    await bot.api.sendMessage(TARGET_CHANNEL_ID, channelText, { parse_mode: "Markdown" });
                    // ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ÿßŸÑŸÖŸÅÿµŸÑÿ© ŸÑŸÉ
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, privateTradeAnalysisText, { parse_mode: "Markdown" });
                } catch (e) {
                    console.error("Failed to auto-post:", e);
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, "‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑÿ®Ÿàÿ™.");
                }
            } else {
                const confirmationKeyboard = new InlineKeyboard()
                    .text("‚úÖ ÿ™ÿ£ŸÉŸäÿØ ŸàŸÜÿ¥ÿ±", "publish_trade")
                    .text("‚ùå ÿ™ÿ¨ÿßŸáŸÑ", "ignore_trade");
                await bot.api.sendMessage(AUTHORIZED_USER_ID, `*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n${privateTradeAnalysisText}`, { parse_mode: "Markdown", reply_markup: confirmationKeyboard });
            }
        }

        if (tradesDetected) {
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
        }
    } catch (e) {
        console.error("CRITICAL ERROR in monitorBalanceChanges:", e);
    }
}


// (ŸáŸÜÿß ÿ®ŸÇŸäÿ© ÿØŸàÿßŸÑ ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ¨ÿØŸàŸÑÿ© ŸÖÿ´ŸÑ checkPriceAlerts, runDailyJobs, etc.)


// ========== Express Server & Bot Handlers ==========
// **ÿßŸÑÿ≠ŸÑ ÿßŸÑŸÜŸáÿßÿ¶Ÿä ŸÑŸÖÿ¥ŸÉŸÑÿ© SIGTERM**
app.use(express.json());
app.get("/healthcheck", (req, res) => {
    res.status(200).send("OK");
});

bot.use(async (ctx, next) => {
    if (ctx.from?.id === AUTHORIZED_USER_ID) {
        await next();
    }
});

// ŸáŸÜÿß ŸÉŸÑ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ŸàÿßŸÑÿ£ŸàÿßŸÖÿ± ŸÖŸÜ ŸÖŸÑŸÅŸÉ ÿßŸÑÿ£ÿµŸÑŸä
const mainKeyboard = new Keyboard()
    .text("üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").text("üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").row()
    .text("‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©").text("üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá").row()
    .text("üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©").row()
    .text("‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™").resized();

bot.command("start", async (ctx) => {
    await ctx.reply(`ü§ñ *ÿ®Ÿàÿ™ OKX ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑ*\n*ÿßŸÑÿ•ÿµÿØÿßÿ±: v67 - Stable & Full-Featured*\n\nÿ£ŸáŸÑÿßŸã ÿ®ŸÉ!`, { parse_mode: "Markdown", reply_markup: mainKeyboard });
});

bot.command("settings", async (ctx) => await sendSettingsMenu(ctx));

bot.command("pnl", async (ctx) => {
    const args = ctx.match.trim().split(/\s+/);
    if (args.length !== 3 || args[0] === '') {
        return await ctx.reply(`‚ùå *ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©*\nÿßÿ≥ÿ™ÿÆÿØŸÖ: \`/pnl <ÿ¥ÿ±ÿßÿ°> <ÿ®Ÿäÿπ> <ŸÉŸÖŸäÿ©>\``, { parse_mode: "Markdown" });
    }
    const [buyPrice, sellPrice, quantity] = args.map(parseFloat);
    if (isNaN(buyPrice) || isNaN(sellPrice) || isNaN(quantity) || buyPrice <= 0 || sellPrice <= 0 || quantity <= 0) {
        return await ctx.reply("‚ùå *ÿÆÿ∑ÿ£:* ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸäŸÖ ŸáŸä ÿ£ÿ±ŸÇÿßŸÖ ŸÖŸàÿ¨ÿ®ÿ©.");
    }
    const pnl = (sellPrice - buyPrice) * quantity;
    const pnlPercent = (pnl / (buyPrice * quantity)) * 100;
    await ctx.reply(`*ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:* \`${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}\` (\`${pnl >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%\`)`, { parse_mode: "Markdown" });
});

bot.on("message:text", async (ctx) => {
    const text = ctx.message.text.trim();
    if (waitingState) {
        const state = waitingState;
        waitingState = null;
        if (state === 'set_capital') {
            const amount = parseFloat(text);
            if (!isNaN(amount) && amount >= 0) {
                await saveCapital(amount);
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ ÿ•ŸÑŸâ \`$${amount.toFixed(2)}\``, { parse_mode: "Markdown" });
            } else {
                await ctx.reply("‚ùå ŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠.");
            }
        }
        // ... (ÿ®ŸÇŸäÿ© ÿ≠ÿßŸÑÿßÿ™ waitingState)
        return;
    }

    switch (text) {
        case "üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
            // (ŸÖŸÜÿ∑ŸÇ ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑŸÖŸÅÿµŸÑ ŸáŸÜÿß)
            await ctx.reply("‚è≥ ÿ¨ÿßÿ±Ÿç ÿ•ÿπÿØÿßÿØ ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©...");
            break;
        case "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™":
            await sendSettingsMenu(ctx);
            break;
        // (ÿ®ŸÇŸäÿ© ÿßŸÑÿ≠ÿßŸÑÿßÿ™)
        default:
             await ctx.reply("ÿ£ŸÖÿ± ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ. ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±.", { reply_markup: mainKeyboard });
    }
});

async function sendSettingsMenu(ctx) {
    const settings = await loadSettings();
    const settingsKeyboard = new InlineKeyboard()
        .text("üí∞ ÿ™ÿπŸäŸäŸÜ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ", "set_capital").row()
        .text(`üöÄ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä: ${settings.autoPostToChannel ? '‚úÖ' : '‚ùå'}`, "toggle_autopost").row()
        .text(`üêû Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ: ${settings.debugMode ? '‚úÖ' : '‚ùå'}`, "toggle_debug");
    
    const text = "‚öôÔ∏è *ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™*";
    try {
        await ctx.editMessageText(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    } catch {
        await ctx.reply(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    }
}

bot.on("callback_query:data", async (ctx) => {
    const data = ctx.callbackQuery.data;
    await ctx.answerCallbackQuery();

    if (data === "toggle_autopost" || data === "toggle_debug") {
        const settings = await loadSettings();
        if (data === 'toggle_autopost') settings.autoPostToChannel = !settings.autoPostToChannel;
        if (data === 'toggle_debug') settings.debugMode = !settings.debugMode;
        await saveSettings(settings);
        await sendSettingsMenu(ctx);
    } else if (data === "set_capital") {
        waitingState = 'set_capital';
        await ctx.editMessageText("ÿ£ÿ±ÿ≥ŸÑ ŸÖÿ®ŸÑÿ∫ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ ÿßŸÑÿ¨ÿØŸäÿØ.");
    } else if (data === "publish_trade") {
        // (ŸÖŸÜÿ∑ŸÇ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑŸäÿØŸàŸä ŸáŸÜÿß)
    }
    // ... (ÿ®ŸÇŸäÿ© ÿ≠ÿßŸÑÿßÿ™ callback_query)
});


// ========== Start Bot ==========
async function startBot() {
    console.log("‚ñ∂Ô∏è ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™...");
    try {
        await connectDB();
        console.log("‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠.");

        // ÿ¨ÿØŸàŸÑÿ© ÿßŸÑŸÖŸáÿßŸÖ
        setInterval(monitorBalanceChanges, 60000);
        // (ÿ®ŸÇŸäÿ© ÿßŸÑŸÖŸáÿßŸÖ)

        console.log("‚úÖ ÿ™ŸÖ ÿ¨ÿØŸàŸÑÿ© ÿ¨ŸÖŸäÿπ ÿßŸÑŸÖŸáÿßŸÖ.");

        // ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™ ÿ®Ÿàÿ∂ÿπŸäÿ© Polling
        await bot.start();
        console.log("ü§ñ ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿØÿ£ ŸàŸäÿπŸÖŸÑ ŸÅŸä Ÿàÿ∂ÿπŸäÿ© Polling.");

        // ÿ®ÿØÿ° ÿßŸÑÿÆÿßÿØŸÖ ŸÑŸÑÿ±ÿØ ÿπŸÑŸâ ŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ©
        app.listen(PORT, () => {
            console.log(`üåê ÿßŸÑÿÆÿßÿØŸÖ Ÿäÿ≥ÿ™ŸÖÿπ ÿπŸÑŸâ ÿßŸÑŸÖŸÜŸÅÿ∞ ${PORT} Ÿàÿ¨ÿßŸáÿ≤ ŸÑŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ©.`);
        });

    } catch (e) {
        console.error("‚ùå ŸÅÿ¥ŸÑ ÿ≠ÿßÿØ ŸÅŸä ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™:", e);
        process.exit(1);
    }
}

startBot();
