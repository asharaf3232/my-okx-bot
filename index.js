// =================================================================
// OKX Advanced Analytics Bot - v59 (FINAL, COMPLETE & CORRECTED)
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard, webhookCallback } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
require("dotenv").config();
const { connectDB, getDB } = require("./database.js");

// --- Bot Setup ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID);
const API_BASE_URL = "https://www.okx.com";

// --- State Variables ---
let waitingState = null;

// === Database Functions ===
const getCollection = (collectionName) => getDB().collection("configs");

async function getConfig(id, defaultValue = {}) {
    const doc = await getCollection("configs").findOne({ _id: id });
    return doc ? doc.data : defaultValue;
}

async function saveConfig(id, data) {
    await getCollection("configs").updateOne({ _id: id }, { $set: { data: data } }, { upsert: true });
}

const loadCapital = async () => (await getConfig("capital", { value: 0 })).value;
const saveCapital = (amount) => saveConfig("capital", { value: amount });
const loadSettings = () => getConfig("settings", { dailySummary: true, autoPostToChannel: false, debugMode: false });
const saveSettings = (settings) => saveConfig("settings", settings);
const loadPositions = () => getConfig("positions", {});
const savePositions = (positions) => saveConfig("positions", positions);
const loadHistory = () => getConfig("dailyHistory", []);
const saveHistory = (history) => saveConfig("dailyHistory", history);
const loadHourlyHistory = () => getConfig("hourlyHistory", []);
const saveHourlyHistory = (history) => saveConfig("hourlyHistory", history);
const loadBalanceState = () => getConfig("balanceState", {});
const saveBalanceState = (state) => saveConfig("balanceState", state);
const loadAlerts = () => getConfig("priceAlerts", []);
const saveAlerts = (alerts) => saveConfig("priceAlerts", alerts);
const loadAlertSettings = () => getConfig("alertSettings", { global: 5, overrides: {} });
const saveAlertSettings = (settings) => saveConfig("alertSettings", settings);
const loadPriceTracker = () => getConfig("priceTracker", { totalPortfolioValue: 0, assets: {} });
const savePriceTracker = (tracker) => saveConfig("priceTracker", tracker);

// === Helper & API Functions ===
async function sendDebugMessage(message) {
    const settings = await loadSettings();
    if (settings.debugMode) {
        try {
            await bot.api.sendMessage(AUTHORIZED_USER_ID, `üêû *Debug:* ${message}`, { parse_mode: "Markdown" });
        } catch (e) {
            console.error("Failed to send debug message:", e);
        }
    }
}

function getHeaders(method, path, body = "") {
    const timestamp = new Date().toISOString();
    const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body);
    const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64");
    return {
        "OK-ACCESS-KEY": process.env.OKX_API_KEY,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE,
        "Content-Type": "application/json",
    };
}

async function getMarketPrices() {
    try {
        const tickersRes = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`);
        const tickersJson = await tickersRes.json();
        if (tickersJson.code !== '0') {
            console.error("Failed to fetch market prices (OKX Error):", tickersJson.msg);
            return null;
        }
        const prices = {};
        tickersJson.data.forEach(t => {
            const lastPrice = parseFloat(t.last);
            const openPrice = parseFloat(t.open24h);
            let change24h = 0;
            if (openPrice > 0) {
                change24h = (lastPrice - openPrice) / openPrice;
            }
            prices[t.instId] = { price: lastPrice, open24h: openPrice, change24h: change24h };
        });
        return prices;
    } catch (error) {
        console.error("Exception in getMarketPrices (Invalid Response):", error.message);
        return null;
    }
}

async function getPortfolio(prices) {
    try {
        const path = "/api/v5/account/balance";
        const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) });
        const json = await res.json();
        if (json.code !== '0') return { error: `ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ŸÖŸÜ OKX: ${json.msg}` };
        
        let assets = [], total = 0;
        json.data[0]?.details?.forEach(asset => {
            const amount = parseFloat(asset.eq);
            if (amount > 0) {
                const instId = `${asset.ccy}-USDT`;
                const priceData = prices[instId] || { price: (asset.ccy === "USDT" ? 1 : 0), change24h: 0 };
                const price = priceData.price;
                const value = amount * price;
                total += value;
                if (value >= 1) {
                    assets.push({ asset: asset.ccy, price: price, value: value, amount: amount, change24h: priceData.change24h });
                }
            }
        });
        
        const filteredAssets = assets.filter(a => a.value >= 1);
        filteredAssets.sort((a, b) => b.value - a.value);
        return { assets: filteredAssets, total };
    } catch (e) {
        console.error(e);
        return { error: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖŸÜÿµÿ©." };
    }
}

async function getBalanceForComparison() {
    try {
        const path = "/api/v5/account/balance";
        const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) });
        const json = await res.json();
        if (json.code !== '0') {
            console.error("Error fetching balance for comparison:", json.msg);
            return null;
        }
        const balanceMap = {};
        json.data[0]?.details?.forEach(asset => {
            const totalBalance = parseFloat(asset.eq);
            if (totalBalance > -1e-9) {
                balanceMap[asset.ccy] = totalBalance;
            }
        });
        return balanceMap;
    } catch (error) {
        console.error("Exception in getBalanceForComparison:", error);
        return null;
    }
}

async function getInstrumentDetails(instId) {
    try {
        const tickerRes = await fetch(`${API_BASE_URL}/api/v5/market/ticker?instId=${instId.toUpperCase()}`);
        const tickerJson = await tickerRes.json();
        if (tickerJson.code !== '0' || !tickerJson.data[0]) return { error: `ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿπŸÖŸÑÿ©.` };
        const tickerData = tickerJson.data[0];
        const candleRes = await fetch(`${API_BASE_URL}/api/v5/market/history-candles?instId=${instId.toUpperCase()}&bar=1D&limit=7`);
        const candleJson = await candleRes.json();
        let weeklyData = { high: 0, low: 0 };
        if (candleJson.code === '0' && candleJson.data.length > 0) {
            const highs = candleJson.data.map(c => parseFloat(c[2]));
            const lows = candleJson.data.map(c => parseFloat(c[3]));
            weeklyData.high = Math.max(...highs);
            weeklyData.low = Math.min(...lows);
        }
        return {
            price: parseFloat(tickerData.last),
            high24h: parseFloat(tickerData.high24h),
            low24h: parseFloat(tickerData.low24h),
            vol24h: parseFloat(tickerData.volCcy24h),
            open24h: parseFloat(tickerData.open24h),
            weeklyHigh: weeklyData.high,
            weeklyLow: weeklyData.low
        };
    } catch (e) {
        console.error(e);
        return { error: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖŸÜÿµÿ©." };
    }
}

async function getHistoricalHighLow(instId, startDate, endDate) {
    try {
        const startMs = new Date(startDate).getTime();
        const endMs = endDate.getTime();
        const res = await fetch(`${API_BASE_URL}/api/v5/market/history-candles?instId=${instId}&bar=1D&before=${startMs}&after=${endMs}`);
        const json = await res.json();
        if (json.code !== '0' || !json.data || json.data.length === 0) {
            console.error(`Could not fetch history for ${instId}:`, json.msg);
            return { high: 0 };
        }
        const highs = json.data.map(c => parseFloat(c[2]));
        return { high: Math.max(...highs) };
    } catch (e) {
        console.error(`Exception in getHistoricalHighLow for ${instId}:`, e);
        return { high: 0 };
    }
}

function calculatePerformanceStats(history) {
    if (history.length < 2) return null;
    const values = history.map(h => h.total);
    const startValue = values[0];
    const endValue = values[values.length - 1];
    const pnl = endValue - startValue;
    const pnlPercent = (startValue > 0) ? (pnl / startValue) * 100 : 0;
    const maxValue = Math.max(...values);
    const minValue = Math.min(...values);
    const avgValue = values.reduce((sum, val) => sum + val, 0) / values.length;
    return { startValue, endValue, pnl, pnlPercent, maxValue, minValue, avgValue };
}

function createChartUrl(history, periodLabel, pnl) {
    if (history.length < 2) return null;
    const chartColor = pnl >= 0 ? 'rgb(75, 192, 75)' : 'rgb(255, 99, 132)';
    const chartBgColor = pnl >= 0 ? 'rgba(75, 192, 75, 0.2)' : 'rgba(255, 99, 132, 0.2)';
    const labels = history.map(h => h.label);
    const data = history.map(h => h.total.toFixed(2));
    const chartConfig = {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'ŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ($)',
                data: data,
                fill: true,
                backgroundColor: chartBgColor,
                borderColor: chartColor,
                tension: 0.1
            }]
        },
        options: {
            title: { display: true, text: `ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© - ${periodLabel}` }
        }
    };
    return `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&backgroundColor=white`;
}

// === Core Logic & Bot Handlers ===
async function updatePositionAndAnalyze(asset, amountChange, price, newTotalAmount) {
    if (!asset || price === undefined || price === null || isNaN(price)) {
        console.error(`Invalid data for updatePositionAndAnalyze: asset=${asset}, price=${price}`);
        return null;
    }
    const positions = await loadPositions();
    const position = positions[asset];
    const tradeValue = Math.abs(amountChange) * price;
    let retrospectiveReport = null;
    if (amountChange > 0) {
        if (!position) {
            positions[asset] = {
                totalAmountBought: amountChange,
                totalCost: tradeValue,
                avgBuyPrice: price,
                openDate: new Date().toISOString(),
                totalAmountSold: 0,
                realizedValue: 0,
            };
        } else {
            position.totalAmountBought += amountChange;
            position.totalCost += tradeValue;
            position.avgBuyPrice = position.totalCost / position.totalAmountBought;
        }
    } else if (amountChange < 0 && position) {
        const amountSold = Math.abs(amountChange);
        position.realizedValue += tradeValue;
        position.totalAmountSold += amountSold;
        if (newTotalAmount * price < 1) {
            await sendDebugMessage(`Position for ${asset} closed. Generating final report...`);
            const finalPnl = position.realizedValue - position.totalCost;
            const finalPnlPercent = (position.totalCost > 0) ? (finalPnl / position.totalCost) * 100 : 0;
            const avgSellPrice = position.totalAmountSold > 0 ? position.realizedValue / position.totalAmountSold : 0;
            const pnlEmoji = finalPnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
            const { high: peakPrice } = await getHistoricalHighLow(`${asset}-USDT`, position.openDate, new Date());
            let efficiencyText = "";
            if (peakPrice > position.avgBuyPrice) {
                const maxPotentialPnl = (peakPrice - position.avgBuyPrice) * position.totalAmountBought;
                if (maxPotentialPnl > 0 && finalPnl > 0) {
                    const exitEfficiency = (finalPnl / maxPotentialPnl) * 100;
                    efficiencyText = `\n - *ŸÉŸÅÿßÿ°ÿ© ÿßŸÑÿÆÿ±Ÿàÿ¨:* ŸÑŸÇÿØ ÿ≠ŸÇŸÇÿ™ **${(exitEfficiency || 0).toFixed(1)}%** ŸÖŸÜ ÿ£ŸÇÿµŸâ ÿ±ÿ®ÿ≠ ŸÖŸÖŸÉŸÜ.`;
                }
            }
            retrospectiveReport = `‚úÖ **ÿ™ŸÇÿ±Ÿäÿ± ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤: ${asset}**\n\n` +
                `*ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ© ŸÑŸÑÿµŸÅŸÇÿ©:* ${pnlEmoji} \`${finalPnl >= 0 ? '+' : ''}${(finalPnl || 0).toFixed(2)}\` (\`${finalPnl >= 0 ? '+' : ''}${(finalPnlPercent || 0).toFixed(2)}%\`)\n\n` +
                `**ŸÖŸÑÿÆÿµ ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ÿØÿßÿ°:**\n` +
                ` - *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${(position.avgBuyPrice || 0).toFixed(4)}\`\n` +
                ` - *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${(avgSellPrice || 0).toFixed(4)}\`\n` +
                ` - *ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ± ÿÆŸÑÿßŸÑ ŸÅÿ™ÿ±ÿ© ÿßŸÑÿ™ŸÖŸÑŸÉ:* \`$${(peakPrice || 0).toFixed(4)}\`` + efficiencyText;
            delete positions[asset];
        } else {
            await sendDebugMessage(`Partial sell for ${asset} recorded.`);
        }
    }
    await savePositions(positions);
    return retrospectiveReport;
}

async function formatPortfolioMsg(assets, total, capital) {
    const positions = await loadPositions();
    let dailyPnlText = " ‚ñ´Ô∏è *ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑŸäŸàŸÖŸä (24ÿ≥):* `ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ≠ÿ≥ÿßÿ®...`\n";
    let totalValue24hAgo = 0;
    assets.forEach(asset => {
        if (asset.asset === 'USDT') {
            totalValue24hAgo += asset.value;
        } else if (asset.change24h !== undefined && asset.price > 0) {
            const price24hAgo = asset.price / (1 + asset.change24h);
            const value24hAgo = asset.amount * price24hAgo;
            totalValue24hAgo += value24hAgo;
        } else {
            totalValue24hAgo += asset.value;
        }
    });
    if (totalValue24hAgo > 0) {
        const dailyPnl = total - totalValue24hAgo;
        const dailyPnlPercent = (dailyPnl / totalValue24hAgo) * 100;
        const dailyPnlEmoji = dailyPnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
        const dailyPnlSign = dailyPnl >= 0 ? '+' : '';
        dailyPnlText = ` ‚ñ´Ô∏è *ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑŸäŸàŸÖŸä (24ÿ≥):* ${dailyPnlEmoji} \`${dailyPnlSign}${(dailyPnl || 0).toFixed(2)}\` (\`${dailyPnlSign}${(dailyPnlPercent || 0).toFixed(2)}%\`)\n`;
    } else {
        dailyPnlText = " ‚ñ´Ô∏è *ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑŸäŸàŸÖŸä (24ÿ≥):* `ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ©`\n";
    }
    let pnl = capital > 0 ? total - capital : 0;
    let pnlPercent = capital > 0 ? (pnl / capital) * 100 : 0;
    let pnlEmoji = pnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
    let pnlSign = pnl >= 0 ? '+' : '';
    const usdtAsset = assets.find(a => a.asset === 'USDT');
    const usdtValue = usdtAsset ? usdtAsset.value : 0;
    const cashPercent = total > 0 ? (usdtValue / total) * 100 : 0;
    const investedPercent = 100 - cashPercent;
    const liquidityText = ` ‚ñ´Ô∏è *ÿ™Ÿàÿ≤Ÿäÿπ ÿßŸÑÿ≥ŸäŸàŸÑÿ©:* üíµ ŸÜŸÇÿØŸä ${(cashPercent || 0).toFixed(1)}% / üìà ŸÖÿ≥ÿ™ÿ´ŸÖÿ± ${(investedPercent || 0).toFixed(1)}%`;
    let msg = `üßæ *ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä ŸÑŸÑŸÖÿ≠ŸÅÿ∏ÿ©*\n\n`;
    msg += `*ÿ®ÿ™ÿßÿ±ŸäÿÆ: ${new Date().toLocaleString("ar-EG", { timeZone: "Africa/Cairo" })}*\n`;
    msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    msg += `üìä *ŸÜÿ∏ÿ±ÿ© ÿπÿßŸÖÿ© ÿπŸÑŸâ ÿßŸÑÿ£ÿØÿßÿ°:*\n`;
    msg += ` ‚ñ´Ô∏è *ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸäÿ©:* \`$${(total || 0).toFixed(2)}\`\n`;
    msg += ` ‚ñ´Ô∏è *ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ ÿßŸÑŸÖÿ≥ÿ¨ŸÑ:* \`$${(capital || 0).toFixed(2)}\`\n`;
    msg += ` ‚ñ´Ô∏è *ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ±ÿ®ÿ≠ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ≠ŸÇŸÇ:* ${pnlEmoji} \`${pnlSign}${(pnl || 0).toFixed(2)}\` (\`${pnlSign}${(pnlPercent || 0).toFixed(2)}%\`)\n`;
    msg += dailyPnlText;
    msg += liquidityText + `\n`;
    msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    msg += `üíé *ŸÖŸÉŸàŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:*\n`;
    assets.forEach((a, index) => {
        let percent = total > 0 ? ((a.value / total) * 100) : 0;
        msg += "\n";
        if (a.asset === "USDT") {
            msg += `*USDT* (ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑŸÜŸÇÿØŸä) üíµ\n`;
            msg += `*ÿßŸÑŸÇŸäŸÖÿ©:* \`$${(a.value || 0).toFixed(2)}\` (*ÿßŸÑŸàÿ≤ŸÜ:* \`${(percent || 0).toFixed(2)}%\`)`;
        } else {
            const change24hPercent = (a.change24h || 0) * 100;
            const changeEmoji = change24hPercent >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
            const changeSign = change24hPercent >= 0 ? '+' : '';
            msg += `‚ï≠‚îÄ *${a.asset}/USDT*\n`;
            msg += `‚îú‚îÄ *ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:* \`$${(a.value || 0).toFixed(2)}\` (*ÿßŸÑŸàÿ≤ŸÜ:* \`${(percent || 0).toFixed(2)}%\`)\n`;
            msg += `‚îú‚îÄ *ÿ≥ÿπÿ± ÿßŸÑÿ≥ŸàŸÇ:* \`$${(a.price || 0).toFixed(4)}\`\n`;
            msg += `‚îú‚îÄ *ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑŸäŸàŸÖŸä:* ${changeEmoji} \`${changeSign}${(change24hPercent || 0).toFixed(2)}%\`\n`;
            const position = positions[a.asset];
            if (position && position.avgBuyPrice > 0) {
                const avgBuyPrice = position.avgBuyPrice;
                const totalCost = avgBuyPrice * a.amount;
                const assetPnl = a.value - totalCost;
                const assetPnlPercent = (totalCost > 0) ? (assetPnl / totalCost) * 100 : 0;
                const assetPnlEmoji = assetPnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
                const assetPnlSign = assetPnl >= 0 ? '+' : '';
                msg += `‚îú‚îÄ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${(avgBuyPrice || 0).toFixed(4)}\`\n`;
                msg += `‚ï∞‚îÄ *ÿ±ÿ®ÿ≠/ÿÆÿ≥ÿßÿ±ÿ© ÿ∫Ÿäÿ± ŸÖÿ≠ŸÇŸÇ:* ${assetPnlEmoji} \`${assetPnlSign}${(assetPnl || 0).toFixed(2)}\` (\`${assetPnlSign}${(assetPnlPercent || 0).toFixed(2)}%\`)`;
            } else {
                msg += `‚ï∞‚îÄ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`ÿ∫Ÿäÿ± ŸÖÿ≥ÿ¨ŸÑ\``;
            }
        }
        if (index < assets.length - 1) {
            msg += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
        }
    });
    return msg;
}

// =================================================================
// START: THE ONLY MODIFIED FUNCTION (monitorBalanceChanges)
// =================================================================
async function monitorBalanceChanges() {
    try {
        await sendDebugMessage("ÿ®ÿØÿ° ÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÅŸÇÿßÿ™...");
        let previousState = await loadBalanceState();
        let previousBalanceState = previousState.balances || {};
        let previousTotalPortfolioValue = previousState.totalValue || 0;

        const currentBalance = await getBalanceForComparison();
        if (!currentBalance) { return; }
        const prices = await getMarketPrices();
        if (!prices) { return; }
        const { total: newTotalPortfolioValue } = await getPortfolio(prices);
        if (newTotalPortfolioValue === undefined) { return; }

        if (Object.keys(previousBalanceState).length === 0) {
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
            await sendDebugMessage("ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑÿ£ŸàŸÑŸä Ÿàÿ≠ŸÅÿ∏Ÿá.");
            return;
        }

        const allAssets = new Set([...Object.keys(previousBalanceState), ...Object.keys(currentBalance)]);
        let tradesDetected = false;

        for (const asset of allAssets) {
            if (asset === 'USDT') continue;
            const prevAmount = previousBalanceState[asset] || 0;
            const currAmount = currentBalance[asset] || 0;
            const difference = currAmount - prevAmount;

            const priceData = prices[`${asset}-USDT`];
            if (!priceData || !priceData.price || isNaN(priceData.price)) continue;
            
            if (Math.abs(difference * priceData.price) < 0.1) continue;

            tradesDetected = true;
            const price = priceData.price;
            
            // This function also handles deleting the position from the DB upon full close
            const retrospectiveReport = await updatePositionAndAnalyze(asset, difference, price, currAmount);

            // If a position was fully closed, the report is generated. We send it and we are done with this asset.
            if (retrospectiveReport) {
                await bot.api.sendMessage(AUTHORIZED_USER_ID, retrospectiveReport, { parse_mode: "Markdown" });
                // We still need to announce the close in the channel, so we don't skip the rest of the logic.
            }
            
            // --- Calculations for the messages ---
            const { assets: currentAssets } = await getPortfolio(prices); 
            const updatedPositions = await loadPositions();
            const currentPosition = updatedPositions[asset];
            
            const tradeValue = Math.abs(difference) * price;
            const newAssetValue = currAmount * price;
            const portfolioPercentage = newTotalPortfolioValue > 0 ? (newAssetValue / newTotalPortfolioValue) * 100 : 0;
            const usdtAsset = currentAssets.find(a => a.asset === 'USDT') || { value: 0 };
            const newCashValue = usdtAsset.value;
            const newCashPercentage = newTotalPortfolioValue > 0 ? (newCashValue / newTotalPortfolioValue) * 100 : 0;
            const entryOfPortfolio = previousTotalPortfolioValue > 0 ? (tradeValue / previousTotalPortfolioValue) * 100 : 0;

            let tradeType, recommendationType;
            if (difference > 0) {
                tradeType = "ÿ¥ÿ±ÿßÿ° üü¢‚¨ÜÔ∏è";
                recommendationType = "ÿ¥ÿ±ÿßÿ° üü¢‚¨ÜÔ∏è";
            } else {
                tradeType = (currAmount * price < 1) ? "ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤ üî¥‚¨áÔ∏è" : "ÿ®Ÿäÿπ ÿ¨ÿ≤ÿ¶Ÿä üü†";
                recommendationType = (currAmount * price < 1) ? "ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿµŸÅŸÇÿ© üî¥‚¨áÔ∏è" : "ÿ®Ÿäÿπ ÿ¨ÿ≤ÿ¶Ÿä üü†";
            }

            // --- Build Private Message ---
            const privateTradeAnalysisText = `üîî **ÿ™ÿ≠ŸÑŸäŸÑ ÿ≠ÿ±ŸÉÿ© ÿ™ÿØÿßŸàŸÑ**\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üî∏ **ÿßŸÑÿπŸÖŸÑŸäÿ©:** ${tradeType}\n` +
                `üî∏ **ÿßŸÑÿ£ÿµŸÑ:** \`${asset}/USDT\`\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµŸÅŸÇÿ©:**\n` +
                ` ‚ñ´Ô∏è *ÿ≥ÿπÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞:* \`$${price.toFixed(4)}\`\n` +
                ` ‚ñ´Ô∏è *ÿßŸÑŸÉŸÖŸäÿ©:* \`${Math.abs(difference).toFixed(5)}\`\n` +
                ` ‚ñ´Ô∏è *ŸÇŸäŸÖÿ© ÿßŸÑÿµŸÅŸÇÿ©:* \`$${tradeValue.toFixed(2)}\`\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` +
                ` ‚ñ´Ô∏è *ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸÅŸÇÿ© ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`${entryOfPortfolio.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è *ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑŸÜŸÇÿØŸä ÿßŸÑÿ¨ÿØŸäÿØ:* \`$${newCashValue.toFixed(2)}\`\n` +
                ` ‚ñ´Ô∏è *ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿ¨ÿØŸäÿØÿ©:* \`${newCashPercentage.toFixed(2)}%\`\n` +
                `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
                `*ÿ®ÿ™ÿßÿ±ŸäÿÆ: ${new Date().toLocaleString("ar-EG", { timeZone: "Africa/Cairo" })}*`;
            
            // --- Build Intelligent Public Message ---
            let publicChannelPostText;
            if (difference > 0) { // It's a BUY
                const initialCash = previousBalanceState['USDT'] || 0;
                const cashConsumptionPercent = initialCash > 0 ? (tradeValue / initialCash) * 100 : 0;
                const averageBuyPrice = currentPosition ? currentPosition.avgBuyPrice : price; 

                publicChannelPostText = `üîî **ÿ™ŸàÿµŸäÿ©: ${recommendationType}**\n\n` +
                    `üî∏ **ÿßŸÑÿ£ÿµŸÑ:** \`${asset}/USDT\`\n\n` +
                    `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ:**\n` +
                    `   ‚ñ´Ô∏è *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${averageBuyPrice.toFixed(4)}\`\n` +
                    `   ‚ñ´Ô∏è *ÿ≠ÿ¨ŸÖ ÿßŸÑÿØÿÆŸàŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`${entryOfPortfolio.toFixed(2)}%\`\n\n` +
                    `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` +
                    `   ‚ñ´Ô∏è *ŸÜÿ≥ÿ®ÿ© ÿßÿ≥ÿ™ŸáŸÑÿßŸÉ ÿßŸÑŸÉÿßÿ¥:* \`${cashConsumptionPercent.toFixed(2)}%\`\n` +
                    `   ‚ñ´Ô∏è *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n\n` +
                    `*ÿ®ÿ™ÿßÿ±ŸäÿÆ: ${new Date().toLocaleDateString("de-DE")}*`;
            } else { // It's a SELL
                publicChannelPostText = `üîî **ÿ™ŸàÿµŸäÿ©: ${recommendationType}**\n\n` +
                    `üî∏ **ÿßŸÑÿ£ÿµŸÑ:** \`${asset}/USDT\`\n\n` +
                    `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿ±Ÿàÿ¨:**\n` +
                    `   ‚ñ´Ô∏è *ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${price.toFixed(4)}\`\n` +
                    `   ‚ñ´Ô∏è *ŸÇŸäŸÖÿ© ÿßŸÑÿµŸÅŸÇÿ©:* \`$${tradeValue.toFixed(2)}\`\n\n` +
                    `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` +
                    `   ‚ñ´Ô∏è *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n` +
                    `   ‚ñ´Ô∏è *ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿ¨ÿØŸäÿØÿ©:* \`${newCashPercentage.toFixed(2)}%\`\n\n` +
                    `*ÿ®ÿ™ÿßÿ±ŸäÿÆ: ${new Date().toLocaleDateString("de-DE")}*`;
            }
            
            // --- Sending Logic ---
            const settings = await loadSettings();
            if (settings.autoPostToChannel) {
                await bot.api.sendMessage(process.env.TARGET_CHANNEL_ID, publicChannelPostText, { parse_mode: "Markdown" });
                // Also send the detailed private message, but only if it's NOT a full close (to avoid duplicate messages)
                if (!retrospectiveReport) {
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, privateTradeAnalysisText, { parse_mode: "Markdown" });
                }
            } else { // Manual Post
                const hiddenMarker = `\n<CHANNEL_POST>${JSON.stringify(publicChannelPostText)}</CHANNEL_POST>`;
                const confirmationKeyboard = new InlineKeyboard()
                    .text("‚úÖ ÿ™ÿ£ŸÉŸäÿØ ŸàŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©", "publish_trade")
                    .text("‚ùå ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿµŸÅŸÇÿ©", "ignore_trade");

                // If it's a full close, show the retrospective report with the buttons. Otherwise, show the trade analysis.
                const textToSend = retrospectiveReport ? retrospectiveReport : privateTradeAnalysisText;
                await bot.api.sendMessage(
                    AUTHORIZED_USER_ID,
                    `*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n${textToSend}${hiddenMarker}`,
                    { parse_mode: "Markdown", reply_markup: confirmationKeyboard }
                );
            }
        }

        if (tradesDetected) {
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
            await sendDebugMessage(`State updated after processing all detected trades.`);
        } else {
            await sendDebugMessage("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™ ŸÅŸä ÿ£ÿ±ÿµÿØÿ© ÿßŸÑÿπŸÖŸÑÿßÿ™.");
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
        }
    } catch (e) {
        console.error("CRITICAL ERROR in monitorBalanceChanges:", e);
    }
}
// =================================================================
// END: THE ONLY MODIFIED FUNCTION
// =================================================================

async function checkPriceAlerts() {
    try {
        const alerts = await loadAlerts();
        if (alerts.length === 0) return;
        const prices = await getMarketPrices();
        if (!prices) return;
        const remainingAlerts = [];
        let alertsTriggered = false;
        for (const alert of alerts) {
            const currentPrice = (prices[alert.instId] || {}).price;
            if (currentPrice === undefined) {
                remainingAlerts.push(alert);
                continue;
            }
            let triggered = false;
            if (alert.condition === '>' && currentPrice > alert.price) triggered = true;
            else if (alert.condition === '<' && currentPrice < alert.price) triggered = true;
            if (triggered) {
                const message = `üö® *ÿ™ŸÜÿ®ŸäŸá ÿ≥ÿπÿ± ŸÖÿ≠ÿØÿØ!* üö®\n\n- *ÿßŸÑÿπŸÖŸÑÿ©:* \`${alert.instId}\`\n- *ÿßŸÑÿ¥ÿ±ÿ∑:* ÿ™ÿ≠ŸÇŸÇ (${alert.condition} ${alert.price})\n- *ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä:* \`${currentPrice}\``;
                await bot.api.sendMessage(AUTHORIZED_USER_ID, message, { parse_mode: "Markdown" });
                alertsTriggered = true;
            } else {
                remainingAlerts.push(alert);
            }
        }
        if (alertsTriggered) {
            await saveAlerts(remainingAlerts);
        }
    } catch (error) {
        console.error("Error in checkPriceAlerts:", error);
    }
}

async function runDailyJobs() {
    try {
        console.log("Attempting to run daily jobs...");
        const settings = await loadSettings();
        if (!settings.dailySummary) {
            console.log("Daily summary is disabled. Skipping.");
            return;
        }
        const prices = await getMarketPrices();
        if (!prices) {
            console.error("Daily Jobs: Failed to get prices from OKX.");
            return;
        }
        const { total, error } = await getPortfolio(prices);
        if (error) {
            console.error("Daily Jobs Error:", error);
            return;
        }
        const history = await loadHistory();
        const date = new Date().toISOString().slice(0, 10);
        const todayRecordIndex = history.findIndex(h => h.date === date);
        if (todayRecordIndex > -1) {
            history[todayRecordIndex].total = total;
        } else {
            history.push({ date: date, total: total });
        }
        if (history.length > 35) history.shift();
        await saveHistory(history);
        console.log(`[‚úÖ Daily Summary Recorded]: ${date} - $${(total || 0).toFixed(2)}`);
    } catch (e) {
        console.error("CRITICAL ERROR in runDailyJobs:", e);
    }
}

async function runHourlyJobs() {
    try {
        const prices = await getMarketPrices();
        if (!prices) return;
        const { total, error } = await getPortfolio(prices);
        if (error) return;
        const history = await loadHourlyHistory();
        const now = new Date();
        const hourLabel = now.toISOString().slice(0, 13);
        const existingIndex = history.findIndex(h => h.label === hourLabel);
        if (existingIndex > -1) {
            history[existingIndex].total = total;
        } else {
            history.push({ label: hourLabel, total: total });
        }
        if (history.length > 72) {
            history.splice(0, history.length - 72);
        }
        await saveHourlyHistory(history);
        await sendDebugMessage(`ÿ™ŸÖ ÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿ¨ŸÑ ÿßŸÑÿ≥ÿßÿπŸä: ${hourLabel} - $${total.toFixed(2)}`);
    } catch (e) {
        console.error("ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑÿ≥ÿßÿπŸäÿ©:", e);
    }
}

async function checkPriceMovements() {
    try {
        await sendDebugMessage("ÿ®ÿØÿ° ÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ£ÿ≥ÿπÿßÿ±...");
        const alertSettings = await loadAlertSettings();
        const priceTracker = await loadPriceTracker();
        const prices = await getMarketPrices();
        if (!prices) {
            await sendDebugMessage("ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿ£ÿ≥ÿπÿßÿ± ÿßŸÑÿ≥ŸàŸÇ (ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©)ÿå ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±ÿ© ŸÅÿ≠ÿµ ÿßŸÑÿ≠ÿ±ŸÉÿ©.");
            return;
        }
        const { assets, total: currentTotalValue, error } = await getPortfolio(prices);
        if (error || currentTotalValue === undefined) {
            await sendDebugMessage("ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©ÿå ÿ™ÿÆÿ∑Ÿä ÿØŸàÿ±ÿ© ŸÅÿ≠ÿµ ÿßŸÑÿ≠ÿ±ŸÉÿ©.");
            return;
        }
        if (priceTracker.totalPortfolioValue === 0) {
            priceTracker.totalPortfolioValue = currentTotalValue;
            assets.forEach(a => {
                if (a.price) priceTracker.assets[a.asset] = a.price;
            });
            await savePriceTracker(priceTracker);
            await sendDebugMessage("ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ŸÇŸäŸÖ ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ÿßŸÑÿ£ŸàŸÑŸäÿ©.");
            return;
        }
        let trackerUpdated = false;
        const lastTotalValue = priceTracker.totalPortfolioValue;
        if (lastTotalValue > 0) {
            const changePercent = ((currentTotalValue - lastTotalValue) / lastTotalValue) * 100;
            if (Math.abs(changePercent) >= alertSettings.global) {
                const emoji = changePercent > 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
                const movementText = changePercent > 0 ? 'ÿµÿπŸàÿØ' : 'Ÿáÿ®Ÿàÿ∑';
                const message = `üìä *ÿ™ŸÜÿ®ŸäŸá ÿ≠ÿ±ŸÉÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸäÿ©!*\n\n*ÿßŸÑÿ≠ÿ±ŸÉÿ©:* ${emoji} *${movementText}* ÿ®ŸÜÿ≥ÿ®ÿ© \`${(changePercent || 0).toFixed(2)}%\`\n*ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:* \`$${(currentTotalValue || 0).toFixed(2)}\``;
                await bot.api.sendMessage(AUTHORIZED_USER_ID, message, { parse_mode: "Markdown" });
                priceTracker.totalPortfolioValue = currentTotalValue;
                trackerUpdated = true;
            }
        }
        for (const asset of assets) {
            if (asset.asset === 'USDT' || !asset.price) continue;
            const lastPrice = priceTracker.assets[asset.asset];
            if (lastPrice) {
                const currentPrice = asset.price;
                const changePercent = ((currentPrice - lastPrice) / lastPrice) * 100;
                const threshold = alertSettings.overrides[asset.asset] || alertSettings.global;
                if (Math.abs(changePercent) >= threshold) {
                    const emoji = changePercent > 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
                    const movementText = changePercent > 0 ? 'ÿµÿπŸàÿØ' : 'Ÿáÿ®Ÿàÿ∑';
                    const message = `üìà *ÿ™ŸÜÿ®ŸäŸá ÿ≠ÿ±ŸÉÿ© ÿ≥ÿπÿ± ŸÑÿ£ÿµŸÑ ŸÖÿ≠ÿØÿØ!*\n\n*ÿßŸÑÿ£ÿµŸÑ:* \`${asset.asset}\`\n*ÿßŸÑÿ≠ÿ±ŸÉÿ©:* ${emoji} *${movementText}* ÿ®ŸÜÿ≥ÿ®ÿ© \`${(changePercent || 0).toFixed(2)}%\`\n*ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä:* \`$${(currentPrice || 0).toFixed(4)}\``;
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, message, { parse_mode: "Markdown" });
                    priceTracker.assets[asset.asset] = currentPrice;
                    trackerUpdated = true;
                }
            } else {
                priceTracker.assets[asset.asset] = asset.price;
                trackerUpdated = true;
            }
        }
        if (trackerUpdated) {
            await savePriceTracker(priceTracker);
            await sendDebugMessage("ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ŸÖÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ÿ®ÿπÿØ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ™ŸÜÿ®ŸäŸá.");
        } else {
            await sendDebugMessage("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ÿ£ÿ≥ÿπÿßÿ± ÿ™ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ≠ÿØ.");
        }
    } catch (e) {
        console.error("CRITICAL ERROR in checkPriceMovements:", e);
    }
}

const mainKeyboard = new Keyboard()
    .text("üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").text("üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").row()
    .text("‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©").text("üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá").row()
    .text("üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©").row()
    .text("‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™").resized();

async function sendSettingsMenu(ctx) {
    const settings = await loadSettings();
    const settingsKeyboard = new InlineKeyboard()
        .text("üí∞ ÿ™ÿπŸäŸäŸÜ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ", "set_capital")
        .text("üíº ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ©", "view_positions").row()
        .text("üö® ÿ•ÿØÿßÿ±ÿ© ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÉÿ©", "manage_movement_alerts")
        .text("üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿ™ŸÜÿ®ŸäŸá ÿ≥ÿπÿ±", "delete_alert").row()
        .text(`üì∞ ÿßŸÑŸÖŸÑÿÆÿµ ÿßŸÑŸäŸàŸÖŸä: ${settings.dailySummary ? '‚úÖ' : '‚ùå'}`, "toggle_summary").row()
        .text(`üöÄ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÑŸÑŸÇŸÜÿßÿ©: ${settings.autoPostToChannel ? '‚úÖ' : '‚ùå'}`, "toggle_autopost")
        .text(`üêû Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ: ${settings.debugMode ? '‚úÖ' : '‚ùå'}`, "toggle_debug").row()
        .text("üî• ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ®Ÿàÿ™ üî•", "delete_all_data");
    const text = "‚öôÔ∏è *ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸàÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©*";
    try {
        await ctx.editMessageText(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    } catch {
        await ctx.reply(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard });
    }
}

async function sendMovementAlertsMenu(ctx) {
    const alertSettings = await loadAlertSettings();
    const text = `üö® *ÿ•ÿØÿßÿ±ÿ© ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ≠ÿ±ŸÉÿ© ÿßŸÑÿ£ÿ≥ÿπÿßÿ±*\n\nÿ™ÿ≥ÿ™ÿÆÿØŸÖ Ÿáÿ∞Ÿá ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ŸÑŸÖÿ±ÿßŸÇÿ®ÿ© ÿßŸÑÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑŸÖÿ¶ŸàŸäÿ© ŸÅŸä ÿßŸÑÿ£ÿ≥ÿπÿßÿ± Ÿàÿ•ÿπŸÑÿßŸÖŸÉ.\n\n- *ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:* ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÜÿ®ŸäŸáŸÉ ŸÑÿ£Ÿä ÿ£ÿµŸÑ Ÿäÿ™ÿ≠ÿ±ŸÉ ÿ®ŸÜÿ≥ÿ®ÿ© \`${alertSettings.global}%\` ÿ£Ÿà ÿ£ŸÉÿ´ÿ±.\n- ŸäŸÖŸÉŸÜŸÉ ÿ™ÿπŸäŸäŸÜ ŸÜÿ≥ÿ®ÿ© ŸÖÿÆÿ™ŸÑŸÅÿ© ŸÑÿπŸÖŸÑÿ© ŸÖÿπŸäŸÜÿ© ŸÑÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿ•ÿπÿØÿßÿØ ÿßŸÑÿπÿßŸÖ.`;
    const keyboard = new InlineKeyboard()
        .text("üìä ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ©", "set_global_alert").row()
        .text("üíé ÿ™ÿπÿØŸäŸÑ ŸÜÿ≥ÿ®ÿ© ÿπŸÖŸÑÿ© ŸÖÿ≠ÿØÿØÿ©", "set_coin_alert").row()
        .text("üìÑ ÿπÿ±ÿ∂ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ©", "view_movement_alerts").row()
        .text("üîô ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™", "back_to_settings");
    try {
        await ctx.editMessageText(text, { parse_mode: "Markdown", reply_markup: keyboard });
    } catch {
        await ctx.reply(text, { parse_mode: "Markdown", reply_markup: keyboard });
    }
}

// === Bot Middleware & Commands ===
bot.use(async (ctx, next) => {
    if (ctx.from?.id === AUTHORIZED_USER_ID) {
        await next();
    } else {
        console.log(`ŸÖÿ≠ÿßŸàŸÑÿ© ŸàÿµŸàŸÑ ÿ∫Ÿäÿ± ŸÖÿµÿ±ÿ≠ ÿ®Ÿá ÿ®Ÿàÿßÿ≥ÿ∑ÿ© ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ: ${ctx.from?.id || 'ÿ∫Ÿäÿ± ŸÖÿ≠ÿØÿØ'}`);
    }
});

bot.command("start", async (ctx) => {
    await ctx.reply(`ü§ñ *ÿ®Ÿàÿ™ OKX ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑ*\n*ÿßŸÑÿ•ÿµÿØÿßÿ±: v59 - Fixed & Complete*\n\nÿ£ŸáŸÑÿßŸã ÿ®ŸÉ! ÿ£ŸÜÿß ŸáŸÜÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä ÿ™ÿ™ÿ®ÿπ Ÿàÿ™ÿ≠ŸÑŸäŸÑ ŸÖÿ≠ŸÅÿ∏ÿ™ŸÉ ÿßŸÑÿßÿ≥ÿ™ÿ´ŸÖÿßÿ±Ÿäÿ©.`, { parse_mode: "Markdown", reply_markup: mainKeyboard });
});

bot.command("settings", async (ctx) => await sendSettingsMenu(ctx));

bot.command("pnl", async (ctx) => {
    const args = ctx.match.trim().split(/\s+/);
    if (args.length !== 3 || args[0] === '') {
        return await ctx.reply(`‚ùå *ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©*\n\n` + `*Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÑŸÑÿ£ŸÖÿ±.*\n\n` + `*ŸÖÿ´ÿßŸÑ:*\n\`/pnl <ÿ≥ÿπÿ± ÿßŸÑÿ¥ÿ±ÿßÿ°> <ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ> <ÿßŸÑŸÉŸÖŸäÿ©>\``, { parse_mode: "Markdown" });
    }
    const [buyPrice, sellPrice, quantity] = args.map(parseFloat);
    if (isNaN(buyPrice) || isNaN(sellPrice) || isNaN(quantity) || buyPrice <= 0 || sellPrice <= 0 || quantity <= 0) {
        return await ctx.reply("‚ùå *ÿÆÿ∑ÿ£:* ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿ¨ŸÖŸäÿπ ÿßŸÑŸÇŸäŸÖ ŸáŸä ÿ£ÿ±ŸÇÿßŸÖ ŸÖŸàÿ¨ÿ®ÿ©.");
    }
    const totalInvestment = buyPrice * quantity;
    const totalSaleValue = sellPrice * quantity;
    const profitOrLoss = totalSaleValue - totalInvestment;
    const pnlPercentage = (profitOrLoss / totalInvestment) * 100;
    const resultStatus = profitOrLoss >= 0 ? "ÿ±ÿ®ÿ≠ ‚úÖ" : "ÿÆÿ≥ÿßÿ±ÿ© üîª";
    const pnlSign = profitOrLoss >= 0 ? '+' : '';
    const responseMessage = `üßÆ *ŸÜÿ™Ÿäÿ¨ÿ© ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©*\n\n` + `üìù **ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™:**\n` + ` - *ÿ≥ÿπÿ± ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${buyPrice.toLocaleString()}\`\n` + ` - *ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${sellPrice.toLocaleString()}\`\n` + ` - *ÿßŸÑŸÉŸÖŸäÿ©:* \`${quantity.toLocaleString()}\`\n\n` + `üìä **ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨:**\n` + ` - *ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ™ŸÉŸÑŸÅÿ© ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${totalInvestment.toLocaleString()}\`\n` + ` - *ÿ•ÿ¨ŸÖÿßŸÑŸä ŸÇŸäŸÖÿ© ÿßŸÑÿ®Ÿäÿπ:* \`$${totalSaleValue.toLocaleString()}\`\n` + ` - *ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©:* \`${pnlSign}${profitOrLoss.toLocaleString()}\` (\`${pnlSign}${(pnlPercentage || 0).toFixed(2)}%\`)\n\n` + `**ÿßŸÑÿ≠ÿßŸÑÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©: ${resultStatus}**`;
    await ctx.reply(responseMessage, { parse_mode: "Markdown" });
});

bot.on("callback_query:data", async (ctx) => {
    try {
        await ctx.answerCallbackQuery();
        const data = ctx.callbackQuery.data;
        if (!ctx.callbackQuery.message) { console.log("Callback query has no message, skipping."); return; }

        if (data.startsWith("chart_")) {
            const period = data.split('_')[1];
            await ctx.editMessageText("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ£ÿØÿßÿ°...");
            let history, periodLabel, periodData;
            if (period === '24h') { history = await loadHourlyHistory(); periodLabel = "ÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©"; periodData = history.slice(-24); }
            else if (period === '7d') { history = await loadHistory(); periodLabel = "ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ"; periodData = history.slice(-7).map(h => ({ label: h.date.slice(5), total: h.total })); }
            else if (period === '30d') { history = await loadHistory(); periodLabel = "ÿ¢ÿÆÿ± 30 ŸäŸàŸÖŸãÿß"; periodData = history.slice(-30).map(h => ({ label: h.date.slice(5), total: h.total })); }
            if (!periodData || periodData.length < 2) { await ctx.editMessageText("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ© ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ŸÑŸáÿ∞Ÿá ÿßŸÑŸÅÿ™ÿ±ÿ©."); return; }
            const stats = calculatePerformanceStats(periodData);
            if (!stats) { await ctx.editMessageText("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ© ŸÑÿ•ŸÜÿ¥ÿßÿ° ÿ™ŸÇÿ±Ÿäÿ± ŸÑŸáÿ∞Ÿá ÿßŸÑŸÅÿ™ÿ±ÿ©."); return; }
            const chartUrl = createChartUrl(periodData, periodLabel, stats.pnl);
            const pnlEmoji = stats.pnl >= 0 ? 'üü¢‚¨ÜÔ∏è' : 'üî¥‚¨áÔ∏è';
            const pnlSign = stats.pnl >= 0 ? '+' : '';
            const caption = `üìä *ÿ™ÿ≠ŸÑŸäŸÑ ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© | ${periodLabel}*\n\n` + `üìà **ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:** ${pnlEmoji} \`${pnlSign}${(stats.pnl || 0).toFixed(2)}\` (\`${pnlSign}${(stats.pnlPercent || 0).toFixed(2)}%\`)\n` + `*ÿßŸÑÿ™ÿ∫Ÿäÿ± ÿßŸÑÿµÿßŸÅŸä: ŸÖŸÜ \`$${(stats.startValue || 0).toFixed(2)}\` ÿ•ŸÑŸâ \`$${(stats.endValue || 0).toFixed(2)}\`*\n\n` + `üìù **ŸÖŸÑÿÆÿµ ÿ•ÿ≠ÿµÿßÿ¶Ÿäÿßÿ™ ÿßŸÑŸÅÿ™ÿ±ÿ©:**\n` + ` ‚ñ´Ô∏è *ÿ£ÿπŸÑŸâ ŸÇŸäŸÖÿ© ŸàÿµŸÑÿ™ ŸÑŸáÿß ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`$${(stats.maxValue || 0).toFixed(2)}\`\n` + ` ‚ñ´Ô∏è *ÿ£ÿØŸÜŸâ ŸÇŸäŸÖÿ© ŸàÿµŸÑÿ™ ŸÑŸáÿß ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`$${(stats.minValue || 0).toFixed(2)}\`\n` + ` ‚ñ´Ô∏è *ŸÖÿ™Ÿàÿ≥ÿ∑ ŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`$${(stats.avgValue || 0).toFixed(2)}\`\n\n` + `*ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿá ŸÅŸä: ${new Date().toLocaleDateString("en-GB").replace(/\//g, '.')}*`;
            try { await ctx.replyWithPhoto(chartUrl, { caption: caption, parse_mode: "Markdown" }); await ctx.deleteMessage(); } catch (e) { console.error("Failed to send chart:", e); await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä. ŸÇÿØ ÿ™ŸÉŸàŸÜ ŸáŸÜÿßŸÉ ŸÖÿ¥ŸÉŸÑÿ© ŸÅŸä ÿÆÿØŸÖÿ© ÿßŸÑÿ±ÿ≥ŸàŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸäÿ©."); }
            return;
        }

        if (data.startsWith("publish_")) {
            const originalText = ctx.callbackQuery.message.text;
            const markerStart = originalText.indexOf("<CHANNEL_POST>");
            const markerEnd = originalText.indexOf("</CHANNEL_POST>");
            let messageForChannel = "ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿßÿ≥ÿ™ÿÆŸÑÿßÿµ ŸÜÿµ ÿßŸÑÿ™ŸàÿµŸäÿ©.";
            if (markerStart !== -1 && markerEnd !== -1) {
                const jsonString = originalText.substring(markerStart + 14, markerEnd);
                try {
                    messageForChannel = JSON.parse(jsonString);
                } catch (e) {
                    console.error("Failed to parse channel post JSON:", e);
                    messageForChannel = originalText.replace(/\n<CHANNEL_POST>[\s\S]*<\/CHANNEL_POST>/, '').replace("*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n", "");
                }
            } else {
                 messageForChannel = originalText.replace("*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n", "");
            }
            try {
                await bot.api.sendMessage(process.env.TARGET_CHANNEL_ID, messageForChannel, { parse_mode: "Markdown" });
                await ctx.editMessageText("‚úÖ ÿ™ŸÖ ŸÜÿ¥ÿ± ÿßŸÑÿµŸÅŸÇÿ© ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠.", { reply_markup: undefined });
            } catch (e) { 
                console.error("Failed to post to channel:", e); 
                await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ®Ÿàÿ™ ŸÑÿØŸäŸá ÿµŸÑÿßÿ≠Ÿäÿßÿ™ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅÿ©.", { reply_markup: undefined }); 
            }
            return;
        }
        if (data === "ignore_trade") { await ctx.editMessageText("‚ùå ÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿµŸÅŸÇÿ© ŸàŸÑŸÜ Ÿäÿ™ŸÖ ŸÜÿ¥ÿ±Ÿáÿß.", { reply_markup: undefined }); return; }

        switch (data) {
            case "view_positions":
                const positions = await loadPositions();
                if (Object.keys(positions).length === 0) { await ctx.editMessageText("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ±ÿßŸÉÿ≤ ŸÖŸÅÿ™Ÿàÿ≠ÿ© ŸÇŸäÿØ ÿßŸÑÿ™ÿ™ÿ®ÿπ ÿ≠ÿßŸÑŸäŸãÿß.", { reply_markup: new InlineKeyboard().text("üîô ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™", "back_to_settings") }); } else {
                    let msg = "üìÑ *ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿßŸÑÿ™Ÿä Ÿäÿ™ŸÖ ÿ™ÿ™ÿ®ÿπŸáÿß ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß:*\n";
                    for (const symbol in positions) { const pos = positions[symbol]; msg += `\n‚ï≠‚îÄ *${symbol}*`; const avgBuyPriceText = pos && pos.avgBuyPrice ? `$${pos.avgBuyPrice.toFixed(4)}` : 'ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠'; const totalAmountText = pos && pos.totalAmountBought ? pos.totalAmountBought.toFixed(6) : 'ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠'; const openDateText = pos && pos.openDate ? new Date(pos.openDate).toLocaleDateString('en-GB') : 'ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠'; msg += `\n‚îú‚îÄ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`${avgBuyPriceText}\``; msg += `\n‚îú‚îÄ *ÿßŸÑŸÉŸÖŸäÿ© ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸäÿ© ÿßŸÑŸÖÿ¥ÿ™ÿ±ÿßÿ©:* \`${totalAmountText}\``; msg += `\n‚ï∞‚îÄ *ÿ™ÿßÿ±ŸäÿÆ ŸÅÿ™ÿ≠ ÿßŸÑŸÖÿ±ŸÉÿ≤:* \`${openDateText}\``; }
                    await ctx.editMessageText(msg, { parse_mode: "Markdown", reply_markup: new InlineKeyboard().text("üîô ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™", "back_to_settings") });
                }
                break;
            case "back_to_settings": await sendSettingsMenu(ctx); break;
            case "manage_movement_alerts": await sendMovementAlertsMenu(ctx); break;
            case "set_global_alert": waitingState = 'set_global_alert_state'; await ctx.editMessageText("‚úçÔ∏è Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ© ÿßŸÑÿπÿßŸÖÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ© ŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÉÿ© (ŸÖÿ´ÿßŸÑ: `5` ŸÑŸÄ 5%)."); break;
            case "set_coin_alert": waitingState = 'set_coin_alert_state'; await ctx.editMessageText("‚úçÔ∏è Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ© ŸàÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿ¶ŸàŸäÿ© ÿßŸÑŸÖÿÆÿµÿµÿ© ŸÑŸáÿß.\n*ŸÖÿ´ÿßŸÑ ŸÑÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá ÿπŸÜÿØ 2.5% ŸÑŸÄ BTC:*\n`BTC 2.5`\n\n*ŸÑÿ≠ÿ∞ŸÅ ÿßŸÑÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿÆÿµÿµ ŸÑÿπŸÖŸÑÿ© ŸÖÿß Ÿàÿ•ÿπÿßÿØÿ™Ÿáÿß ŸÑŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ©ÿå ÿ£ÿ±ÿ≥ŸÑ ŸÜÿ≥ÿ®ÿ© 0.*"); break;
            case "view_movement_alerts": const alertSettings = await loadAlertSettings(); let msg_alerts = `üö® *ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÉÿ©:*\n\n` + `*ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ© (Global):* \`${alertSettings.global}%\`\n` + `--------------------\n*ÿßŸÑŸÜÿ≥ÿ® ÿßŸÑŸÖÿÆÿµÿµÿ© (Overrides):*\n`; if (Object.keys(alertSettings.overrides).length === 0) { msg_alerts += "ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÜÿ≥ÿ® ŸÖÿÆÿµÿµÿ© ÿ≠ÿßŸÑŸäŸãÿß." } else { for (const coin in alertSettings.overrides) { msg_alerts += `- *${coin}:* \`${alertSettings.overrides[coin]}%\`\n`; } } await ctx.editMessageText(msg_alerts, { parse_mode: "Markdown", reply_markup: new InlineKeyboard().text("üîô ÿßŸÑÿπŸàÿØÿ©", "manage_movement_alerts") }); break;
            case "set_capital": waitingState = 'set_capital'; await ctx.editMessageText("üí∞ Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ (ÿ±ŸÇŸÖ ŸÅŸÇÿ∑).", { reply_markup: undefined }); break;
            case "delete_alert": const alerts = await loadAlerts(); if (alerts.length === 0) { await ctx.editMessageText("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ≥ÿπÿ± ŸÖÿ≠ÿØÿØ ŸÖÿ≥ÿ¨ŸÑÿ© ÿ≠ÿßŸÑŸäŸãÿß.", { reply_markup: new InlineKeyboard().text("üîô ÿßŸÑÿπŸàÿØÿ© ÿ•ŸÑŸâ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™", "back_to_settings") }); } else { let msg = "üóëÔ∏è *ŸÇÿßÿ¶ŸÖÿ© ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ≥ÿπÿ± ÿßŸÑŸÖÿ≥ÿ¨ŸÑÿ©:*\n\n"; alerts.forEach((alert, index) => { msg += `*${index + 1}.* \`${alert.instId}\` ÿπŸÜÿØŸÖÿß ŸäŸÉŸàŸÜ ÿßŸÑÿ≥ÿπÿ± ${alert.condition === '>' ? 'ÿ£ÿπŸÑŸâ ŸÖŸÜ' : 'ÿ£ŸÇŸÑ ŸÖŸÜ'} \`${alert.price}\`\n`; }); msg += "\n*Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿßŸÑÿ∞Ÿä ÿ™ŸàÿØ ÿ≠ÿ∞ŸÅŸá.*"; waitingState = 'delete_alert_number'; await ctx.editMessageText(msg, { parse_mode: "Markdown" }); } break;
            case "toggle_summary": case "toggle_autopost": case "toggle_debug": { let settings = await loadSettings(); if (data === 'toggle_summary') settings.dailySummary = !settings.dailySummary; else if (data === 'toggle_autopost') settings.autoPostToChannel = !settings.autoPostToChannel; else if (data === 'toggle_debug') settings.debugMode = !settings.debugMode; await saveSettings(settings); await sendSettingsMenu(ctx); } break;
            case "delete_all_data": waitingState = 'confirm_delete_all'; await ctx.editMessageText("‚ö†Ô∏è *ÿ™ÿ≠ÿ∞Ÿäÿ±: Ÿáÿ∞ÿß ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ° ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ±ÿßÿ¨ÿπ ÿπŸÜŸá!* ‚ö†Ô∏è\n\nÿ≥Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©ÿå ÿ®ŸÖÿß ŸÅŸä ÿ∞ŸÑŸÉ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑÿå ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ÿå ÿ≥ÿ¨ŸÑ ÿßŸÑÿ£ÿØÿßÿ°ÿå Ÿàÿ¨ŸÖŸäÿπ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™.\n\n*ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©ÿå ÿ£ÿ±ÿ≥ŸÑ ŸÉŸÑŸÖÿ©: `ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ`*", { parse_mode: "Markdown", reply_markup: undefined }); setTimeout(() => { if (waitingState === 'confirm_delete_all') waitingState = null; }, 30000); break;
        }
    } catch (error) { console.error("Caught a critical error in callback_query handler:", error); }
});

bot.on("message:text", async (ctx) => {
    try {
        const text = ctx.message.text.trim();
        if (ctx.message.text && ctx.message.text.startsWith('/')) { return; }
        switch (text) {
            case "üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
                await ctx.reply("‚è≥ ŸÑÿ≠ÿ∏ÿßÿ™... ÿ¨ÿßÿ±Ÿä ÿ•ÿπÿØÿßÿØ ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©.");
                const pricesPortfolio = await getMarketPrices();
                if (!pricesPortfolio) { return await ctx.reply("‚ùå ÿπÿ∞ÿ±Ÿãÿßÿå ŸÅÿ¥ŸÑ ŸÅŸä ÿ¨ŸÑÿ® ÿ£ÿ≥ÿπÿßÿ± ÿßŸÑÿ≥ŸàŸÇ ŸÖŸÜ OKX ÿ≠ÿßŸÑŸäŸãÿß (ÿßÿ≥ÿ™ÿ¨ÿßÿ®ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©). Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ŸÑÿßÿ≠ŸÇŸãÿß."); }
                const capital = await loadCapital();
                const { assets, total, error } = await getPortfolio(pricesPortfolio);
                if (error) { return await ctx.reply(`‚ùå ${error}`); }
                const msgPortfolio = await formatPortfolioMsg(assets, total, capital);
                await ctx.reply(msgPortfolio, { parse_mode: "Markdown" });
                return;
            case "üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©": const performanceKeyboard = new InlineKeyboard().text("ÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©", "chart_24h").row().text("ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ", "chart_7d").row().text("ÿ¢ÿÆÿ± 30 ŸäŸàŸÖŸãÿß", "chart_30d"); await ctx.reply("ÿßÿÆÿ™ÿ± ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ© ÿßŸÑŸÖÿ∑ŸÑŸàÿ®ÿ© ŸÑÿπÿ±ÿ∂ ÿ™ŸÇÿ±Ÿäÿ± ÿßŸÑÿ£ÿØÿßÿ°:", { reply_markup: performanceKeyboard }); return;
            case "‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©": waitingState = 'coin_info'; await ctx.reply("‚úçÔ∏è Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ© (ŸÖÿ´ÿßŸÑ: `BTC-USDT`)."); return;
            case "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™": await sendSettingsMenu(ctx); return;
            case "üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá": waitingState = 'set_alert'; await ctx.reply("‚úçÔ∏è *ŸÑÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá ÿ≥ÿπÿ± ŸÖÿ≠ÿØÿØÿå ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:*\n`<ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ©> < > ÿ£Ÿà < > <ÿßŸÑÿ≥ÿπÿ±>`\n\n*ÿ£ŸÖÿ´ŸÑÿ©:*\n`BTC-USDT > 70000`\n`ETH-USDT < 3500`", { parse_mode: "Markdown" }); return;
            case "üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©": await ctx.reply("‚úçÔ∏è ŸÑÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© ŸÑÿµŸÅŸÇÿ© ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ©ÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ£ŸÖÿ± `/pnl`.\n\n*ŸÖÿ´ÿßŸÑ:*\n`/pnl 50000 60000 0.5`", { parse_mode: "Markdown" }); return;
        }
        if (waitingState) {
            const state = waitingState;
            waitingState = null;
            switch (state) {
                case 'set_capital': const amount = parseFloat(text); if (!isNaN(amount) && amount >= 0) { await saveCapital(amount); await ctx.reply(`‚úÖ *ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ ÿ®ŸÜÿ¨ÿßÿ≠.*\n\nüí∞ **ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ¨ÿØŸäÿØ:** \`$${(amount || 0).toFixed(2)}\``, { parse_mode: "Markdown" }); } else { await ctx.reply("‚ùå ŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÇŸÖ ŸÅŸÇÿ∑."); } return;
                case 'set_global_alert_state': const percent = parseFloat(text); if (isNaN(percent) || percent <= 0) { return await ctx.reply("‚ùå *ÿÆÿ∑ÿ£:* ÿßŸÑŸÜÿ≥ÿ®ÿ© Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ±ŸÇŸÖŸãÿß ŸÖŸàÿ¨ÿ®Ÿãÿß."); } let alertSettingsGlobal = await loadAlertSettings(); alertSettingsGlobal.global = percent; await saveAlertSettings(alertSettingsGlobal); await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ© ŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑÿ≠ÿ±ŸÉÿ© ÿ•ŸÑŸâ \`${percent}%\`.`); return;
                case 'set_coin_alert_state': const parts_coin_alert = text.split(/\s+/); if (parts_coin_alert.length !== 2) { return await ctx.reply("‚ùå *ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©*. Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ© ÿ´ŸÖ ÿßŸÑŸÜÿ≥ÿ®ÿ©."); } const [symbol_coin_alert, percentStr_coin_alert] = parts_coin_alert; const coinPercent = parseFloat(percentStr_coin_alert); if (isNaN(coinPercent) || coinPercent < 0) { return await ctx.reply("‚ùå *ÿÆÿ∑ÿ£:* ÿßŸÑŸÜÿ≥ÿ®ÿ© Ÿäÿ¨ÿ® ÿ£ŸÜ ÿ™ŸÉŸàŸÜ ÿ±ŸÇŸÖŸãÿß."); } let alertSettingsCoin = await loadAlertSettings(); if (coinPercent === 0) { delete alertSettingsCoin.overrides[symbol_coin_alert.toUpperCase()]; await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ•ÿπÿØÿßÿØ ÿßŸÑŸÖÿÆÿµÿµ ŸÑŸÄ *${symbol_coin_alert.toUpperCase()}* Ÿàÿ≥ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ¢ŸÜ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑÿπÿßŸÖÿ©.`); } else { alertSettingsCoin.overrides[symbol_coin_alert.toUpperCase()] = coinPercent; await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÖÿÆÿµÿµÿ© ŸÑŸÄ *${symbol_coin_alert.toUpperCase()}* ÿ•ŸÑŸâ \`${coinPercent}%\`.`); } await saveAlertSettings(alertSettingsCoin); return;
                case 'coin_info':
                    const instId = text.toUpperCase();
                    await ctx.reply(`‚è≥ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ÿ®ŸäÿßŸÜÿßÿ™ ${instId}...`);
                    const details = await getInstrumentDetails(instId);
                    if (details.error) { return await ctx.reply(`‚ùå ${details.error}`); }
                    let msg = `‚ÑπÔ∏è *ÿ™ŸÇÿ±Ÿäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ≥ŸàŸÇ | ${instId}*\n\n` + ` ‚ñ´Ô∏è *ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä:* \`$${(details.price || 0).toFixed(4)}\`\n` + ` ‚ñ´Ô∏è *ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ± (24ÿ≥):* \`$${(details.high24h || 0).toFixed(4)}\`\n` + ` ‚ñ´Ô∏è *ÿ£ÿØŸÜŸâ ÿ≥ÿπÿ± (24ÿ≥):* \`$${(details.low24h || 0).toFixed(4)}\`\n\n` + ` ‚ñ´Ô∏è *ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑÿ≥ÿπÿ±Ÿä ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä (ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ):*\n` + ` *ÿßŸÑÿ£ÿπŸÑŸâ:* \`$${(details.weeklyHigh || 0).toFixed(4)}\` | *ÿßŸÑÿ£ÿØŸÜŸâ:* \`$${(details.weeklyLow || 0).toFixed(4)}\`\n\n` + ` ‚ñ´Ô∏è *ÿ≠ÿ¨ŸÖ ÿßŸÑÿ™ÿØÿßŸàŸÑ (24ÿ≥):* \`$${(details.vol24h || 0).toLocaleString()}\`\n\n` + `*ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ ŸÖŸÜÿµÿ© OKX*`;
                    const prices = await getMarketPrices();
                    if (prices) { const { assets: userAssets } = await getPortfolio(prices); const coinSymbol = instId.split('-')[0]; const ownedAsset = userAssets.find(a => a.asset === coinSymbol); const positions = await loadPositions(); const assetPosition = positions[coinSymbol]; if (ownedAsset && assetPosition && assetPosition.avgBuyPrice) { const amount = ownedAsset.amount; const avgBuyPrice = assetPosition.avgBuyPrice; const totalCost = avgBuyPrice * amount; const totalPnl = (details.price * amount) - totalCost; const totalPnlPercent = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0; const totalPnlEmoji = totalPnl >= 0 ? 'üü¢' : 'üî¥'; const totalPnlSign = totalPnl >= 0 ? '+' : ''; const dailyPnl = (details.price - details.open24h) * amount; const dailyPnlEmoji = dailyPnl >= 0 ? 'üü¢' : 'üî¥'; const dailyPnlSign = dailyPnl >= 0 ? '+' : ''; msg += `\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` + `üìä *ÿ™ÿ≠ŸÑŸäŸÑ ŸÖÿ±ŸÉÿ≤ŸÉ ŸÅŸä ÿßŸÑÿπŸÖŸÑÿ©:*\n` + ` ‚ñ´Ô∏è *ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä (ÿ∫Ÿäÿ± ŸÖÿ≠ŸÇŸÇ):* ${totalPnlEmoji} \`${totalPnlSign}${(totalPnl || 0).toFixed(2)}\` (\`${totalPnlSign}${(totalPnlPercent || 0).toFixed(2)}%\`)\n` + ` ‚ñ´Ô∏è *ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© (ÿ¢ÿÆÿ± 24ÿ≥):* ${dailyPnlEmoji} \`${dailyPnlSign}${(dailyPnl || 0).toFixed(2)}\``; } }
                    await ctx.reply(msg, { parse_mode: "Markdown" });
                    return;
                case 'set_alert':
                    const parts_alert = text.trim().split(/\s+/);
                    if (parts_alert.length !== 3) { return await ctx.reply("‚ùå ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: `SYMBOL > PRICE`"); }
                    const [alertInstId, condition, priceStr] = parts_alert;
                    if (condition !== '>' && condition !== '<') { return await ctx.reply("‚ùå ÿßŸÑÿ¥ÿ±ÿ∑ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. ÿßÿ≥ÿ™ÿÆÿØŸÖ `>` ÿ£Ÿà `<` ŸÅŸÇÿ∑."); }
                    const alertPrice = parseFloat(priceStr);
                    if (isNaN(alertPrice) || alertPrice <= 0) { return await ctx.reply("‚ùå ÿßŸÑÿ≥ÿπÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠."); }
                    const alertsList = await loadAlerts();
                    alertsList.push({ instId: alertInstId.toUpperCase(), condition: condition, price: alertPrice });
                    await saveAlerts(alertsList);
                    await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ∂ÿ®ÿ∑ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿ®ŸÜÿ¨ÿßÿ≠:\nÿ≥Ÿäÿ™ŸÖ ÿ•ÿπŸÑÿßŸÖŸÉ ÿ•ÿ∞ÿß ÿ£ÿµÿ®ÿ≠ ÿ≥ÿπÿ± *${alertInstId.toUpperCase()}* ${condition === '>' ? 'ÿ£ÿπŸÑŸâ ŸÖŸÜ' : 'ÿ£ŸÇŸÑ ŸÖŸÜ'} *${alertPrice}*`, { parse_mode: "Markdown" });
                    return;
                case 'delete_alert_number':
                    const alertIndex = parseInt(text) - 1;
                    let currentAlerts = await loadAlerts();
                    if (isNaN(alertIndex) || alertIndex < 0 || alertIndex >= currentAlerts.length) {
                        return await ctx.reply("‚ùå ÿ±ŸÇŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©.");
                    }
                    const removedAlert = currentAlerts.splice(alertIndex, 1)[0];
                    await saveAlerts(currentAlerts);
                    await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿ®ŸÜÿ¨ÿßÿ≠:\n\`${removedAlert.instId} ${removedAlert.condition} ${removedAlert.price}\``, { parse_mode: "Markdown" });
                    return;
                case 'confirm_delete_all': if (text === 'ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ') { await getCollection("configs").deleteMany({}); await ctx.reply("‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿ®ŸäÿßŸÜÿßÿ™ŸÉ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ© ÿ®ŸÜÿ¨ÿßÿ≠. ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ®ÿØÿ° ŸÖŸÜ ÿ¨ÿØŸäÿØ."); } else { await ctx.reply("‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≠ÿ∞ŸÅ."); } return;
            }
        }
    } catch (error) { console.error("Caught a critical error in message:text handler:", error); }
});

// === Healthcheck endpoint for hosting platforms ===
app.get("/healthcheck", (req, res) => {
    res.status(200).send("OK");
});

// === Start Bot ===
async function startBot() {
    try {
        await connectDB();
        console.log("MongoDB connected.");

        // Schedule Jobs
        setInterval(monitorBalanceChanges, 60000); // Check for trades every 60s
        setInterval(checkPriceAlerts, 30000);      // Check price alerts every 30s
        setInterval(checkPriceMovements, 60000);   // Check for significant price movements every 60s
        setInterval(runHourlyJobs, 3600000);       // Run hourly jobs every hour
        setInterval(runDailyJobs, 86400000);       // Run daily jobs every 24 hours

        if (process.env.NODE_ENV === "production") {
            app.use(express.json());
            app.use(webhookCallback(bot, "express"));
            app.listen(PORT, () => {
                console.log(`Server on port ${PORT}`);
            });
        } else {
            await bot.start();
            console.log("Bot started with polling.");
        }
    } catch (e) {
        console.error("FATAL: Could not start the bot.", e);
    }
}

startBot();
