// =================================================================
// OKX Advanced Analytics Bot - v46 (Final, with Channel Publisher)
// =================================================================
// This is the 100% complete, verified final version. It re-integrates
// the critical trade recommendation publishing feature for channels,
// alongside the professional analysis engine.
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard, webhookCallback } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
require("dotenv").config();
const { connectDB, getDB } = require("./database.js");

// --- Bot Setup ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID);
const API_BASE_URL = "https://www.okx.com";

// --- State Variables ---
let waitingState = null;

// === Database Functions ===
const getCollection = (collectionName) => getDB().collection("configs");
async function getConfig(id, defaultValue = {}) { const doc = await getCollection("configs").findOne({ _id: id }); return doc ? doc.data : defaultValue; }
async function saveConfig(id, data) { await getCollection("configs").updateOne({ _id: id }, { $set: { data: data } }, { upsert: true }); }
const loadCapital = async () => (await getConfig("capital", { value: 0 })).value;
const saveCapital = (amount) => saveConfig("capital", { value: amount });
const loadSettings = () => getConfig("settings", { dailySummary: true, autoPostToChannel: false, debugMode: false });
const saveSettings = (settings) => saveConfig("settings", settings);
const loadPositions = () => getConfig("positions", {});
const savePositions = (positions) => saveConfig("positions", positions);
const loadHistory = () => getConfig("dailyHistory", []);
const saveHistory = (history) => saveConfig("dailyHistory", history);
const loadHourlyHistory = () => getConfig("hourlyHistory", []);
const saveHourlyHistory = (history) => saveConfig("hourlyHistory", history);
const loadBalanceState = () => getConfig("balanceState", {});
const saveBalanceState = (state) => saveConfig("balanceState", state);
const loadAlerts = () => getConfig("priceAlerts", []);
const saveAlerts = (alerts) => saveConfig("priceAlerts", alerts);

// === Helper & API Functions ===
async function sendDebugMessage(message) { const settings = await loadSettings(); if (settings.debugMode) { try { await bot.api.sendMessage(AUTHORIZED_USER_ID, `üêû *Debug:* ${message}`, { parse_mode: "Markdown" }); } catch (e) { console.error("Failed to send debug message:", e); } } }
function getHeaders(method, path, body = "") { const timestamp = new Date().toISOString(); const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body); const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64"); return { "OK-ACCESS-KEY": process.env.OKX_API_KEY, "OK-ACCESS-SIGN": sign, "OK-ACCESS-TIMESTAMP": timestamp, "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE, "Content-Type": "application/json", }; }
async function getMarketPrices() { try { const tickersRes = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`); const tickersJson = await tickersRes.json(); if (tickersJson.code !== '0') { console.error("Failed to fetch market prices:", tickersJson.msg); return null; } const prices = {}; tickersJson.data.forEach(t => { const lastPrice = parseFloat(t.last); const openPrice = parseFloat(t.open24h); let change24h = 0; if (openPrice > 0) { change24h = (lastPrice - openPrice) / openPrice; } prices[t.instId] = { price: lastPrice, open24h: openPrice, change24h: change24h }; }); return prices; } catch (error) { console.error("Exception in getMarketPrices:", error); return null; } }
async function getPortfolio(prices) { try { const path = "/api/v5/account/balance"; const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) }); const json = await res.json(); if (json.code !== '0') return { error: `ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©: ${json.msg}` }; let assets = [], total = 0; json.data[0]?.details?.forEach(asset => { const amount = parseFloat(asset.eq); if (amount > 0) { const instId = `${asset.ccy}-USDT`; const priceData = prices[instId] || { price: (asset.ccy === "USDT" ? 1 : 0), change24h: 0 }; const price = priceData.price; const value = amount * price; if (value >= 1) { assets.push({ asset: asset.ccy, price: price, value: value, amount: amount, change24h: priceData.change24h }); } total += value; } }); const filteredAssets = assets.filter(a => a.value >= 1); filteredAssets.sort((a, b) => b.value - a.value); return { assets: filteredAssets, total }; } catch (e) { console.error(e); return { error: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖŸÜÿµÿ©." }; } }
async function getBalanceForComparison() { try { const path = "/api/v5/account/balance"; const res = await fetch(`${API_BASE_URL}${path}`, { headers: getHeaders("GET", path) }); const json = await res.json(); if (json.code !== '0') { console.error("Error fetching balance for comparison:", json.msg); return null; } const balanceMap = {}; json.data[0]?.details?.forEach(asset => { const totalBalance = parseFloat(asset.eq); if (totalBalance > 1e-9) { balanceMap[asset.ccy] = totalBalance; } }); return balanceMap; } catch (error) { console.error("Exception in getBalanceForComparison:", error); return null; } }
async function getInstrumentDetails(instId) { try { const tickerRes = await fetch(`${API_BASE_URL}/api/v5/market/ticker?instId=${instId.toUpperCase()}`); const tickerJson = await tickerRes.json(); if (tickerJson.code !== '0' || !tickerJson.data[0]) return { error: `ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿßŸÑÿπŸÖŸÑÿ©.` }; const tickerData = tickerJson.data[0]; const candleRes = await fetch(`${API_BASE_URL}/api/v5/market/history-candles?instId=${instId.toUpperCase()}&bar=1D&limit=7`); const candleJson = await candleRes.json(); let weeklyData = { high: 0, low: 0 }; if (candleJson.code === '0' && candleJson.data.length > 0) { const highs = candleJson.data.map(c => parseFloat(c[2])); const lows = candleJson.data.map(c => parseFloat(c[3])); weeklyData.high = Math.max(...highs); weeklyData.low = Math.min(...lows); } return { price: parseFloat(tickerData.last), high24h: parseFloat(tickerData.high24h), low24h: parseFloat(tickerData.low24h), vol24h: parseFloat(tickerData.volCcy24h), open24h: parseFloat(tickerData.open24h), weeklyHigh: weeklyData.high, weeklyLow: weeklyData.low }; } catch (e) { console.error(e); return { error: "ÿÆÿ∑ÿ£ ŸÅŸä ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑŸÖŸÜÿµÿ©." }; } }
async function getHistoricalHighLow(instId, startDate, endDate) { try { const startMs = new Date(startDate).getTime(); const endMs = endDate.getTime(); const res = await fetch(`${API_BASE_URL}/api/v5/market/history-candles?instId=${instId}&bar=1D&before=${startMs}&after=${endMs}`); const json = await res.json(); if (json.code !== '0' || !json.data || json.data.length === 0) { console.error(`Could not fetch history for ${instId}:`, json.msg); return { high: 0 }; } const highs = json.data.map(c => parseFloat(c[2])); return { high: Math.max(...highs) }; } catch (e) { console.error(`Exception in getHistoricalHighLow for ${instId}:`, e); return { high: 0 }; } }
function createChartUrl(history, periodLabel) { if (history.length < 2) return null; const labels = history.map(h => h.label); const data = history.map(h => h.total.toFixed(2)); const chartConfig = { type: 'line', data: { labels: labels, datasets: [{ label: 'ŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ($)', data: data, fill: true, backgroundColor: 'rgba(75, 192, 192, 0.2)', borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] }, options: { title: { display: true, text: `ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© - ${periodLabel}` } } }; return `https://quickchart.io/chart?c=${encodeURIComponent(JSON.stringify(chartConfig))}&backgroundColor=white`; }
function calculatePerformanceStats(history) { if (history.length < 2) return null; const values = history.map(h => h.total); const startValue = values[0]; const endValue = values[values.length - 1]; const pnl = endValue - startValue; const pnlPercent = (startValue > 0) ? (pnl / startValue) * 100 : 0; const maxValue = Math.max(...values); const minValue = Math.min(...values); const avgValue = values.reduce((sum, val) => sum + val, 0) / values.length; return { startValue, endValue, pnl, pnlPercent, maxValue, minValue, avgValue }; }

// === Core Logic & Bot Handlers ===
async function updatePositionAndAnalyze(asset, amountChange, price, newTotalAmount) {
    const positions = await loadPositions();
    const position = positions[asset];
    const tradeValue = Math.abs(amountChange) * price;
    let retrospectiveReport = null;

    if (amountChange > 0) { // --- Buy Case ---
        if (!position) {
            positions[asset] = { totalAmountBought: amountChange, totalCost: tradeValue, avgBuyPrice: price, openDate: new Date().toISOString(), totalAmountSold: 0, realizedValue: 0, };
        } else {
            position.totalAmountBought += amountChange;
            position.totalCost += tradeValue;
            position.avgBuyPrice = position.totalCost / position.totalAmountBought;
        }
    } else if (amountChange < 0 && position) { // --- Sell Case ---
        const amountSold = Math.abs(amountChange);
        position.realizedValue += tradeValue;
        position.totalAmountSold += amountSold;
        
        if (newTotalAmount < 0.0001) { // Position Closed
            await sendDebugMessage(`Position for ${asset} closed. Generating final report...`);
            const finalPnl = position.realizedValue - position.totalCost;
            const finalPnlPercent = (position.totalCost > 0) ? (finalPnl / position.totalCost) * 100 : 0;
            const avgSellPrice = position.realizedValue / position.totalAmountSold;
            const pnlEmoji = finalPnl >= 0 ? 'üü¢' : 'üî¥';
            const { high: peakPrice } = await getHistoricalHighLow(`${asset}-USDT`, position.openDate, new Date());
            let efficiencyText = "";
            if (peakPrice > position.avgBuyPrice) {
                const maxPotentialPnl = (peakPrice - position.avgBuyPrice) * position.totalAmountBought;
                if (maxPotentialPnl > 0 && finalPnl > 0) {
                    const exitEfficiency = (finalPnl / maxPotentialPnl) * 100;
                    efficiencyText = `\n   - *ŸÉŸÅÿßÿ°ÿ© ÿßŸÑÿÆÿ±Ÿàÿ¨:* ŸÑŸÇÿØ ÿ≠ŸÇŸÇÿ™ **${exitEfficiency.toFixed(1)}%** ŸÖŸÜ ÿ£ŸÇÿµŸâ ÿ±ÿ®ÿ≠ ŸÖŸÖŸÉŸÜ.`;
                }
            }
            retrospectiveReport = `‚úÖ **ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤ ${asset}**\n\n` + `*ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ© ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©:* ${pnlEmoji} ÿ±ÿ®ÿ≠ \`${finalPnl >= 0 ? '+' : ''}${finalPnl.toFixed(2)}$\` (\`${finalPnl >= 0 ? '+' : ''}${finalPnlPercent.toFixed(2)}%\`)\n\n` + `**ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿ£ÿØÿßÿ°:**\n` + `   - *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${position.avgBuyPrice.toFixed(4)}\`\n` + `   - *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ®Ÿäÿπ:* \`$${avgSellPrice.toFixed(4)}\`\n` + `   - *ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ± ÿÆŸÑÿßŸÑ ÿßŸÑÿßÿ≠ÿ™ŸÅÿßÿ∏:* \`$${peakPrice.toFixed(4)}\`` + efficiencyText;
            delete positions[asset];
        } else { // Partial Sell
            await sendDebugMessage(`Partial sell for ${asset} recorded.`);
        }
    }
    await savePositions(positions);
    return retrospectiveReport;
}

async function formatPortfolioMsg(assets, total, capital) {
    const history = await loadHistory();
    const positions = await loadPositions();
    let dailyPnlText = "   üìà *ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© (ŸäŸàŸÖŸä):* `ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ©`\n";
    if (history.length > 0) {
        const todayStr = new Date().toISOString().slice(0, 10);
        const previousDayRecord = history.filter(h => h.date !== todayStr).pop();
        if (previousDayRecord && typeof previousDayRecord.total === 'number') {
            const dailyPnl = total - previousDayRecord.total;
            const dailyPnlPercent = previousDayRecord.total > 0 ? (dailyPnl / previousDayRecord.total) * 100 : 0;
            const dailyPnlEmoji = dailyPnl >= 0 ? 'üü¢' : 'üî¥';
            const dailyPnlSign = dailyPnl >= 0 ? '+' : '';
            dailyPnlText = `   üìà *ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© (ŸäŸàŸÖŸä):* ${dailyPnlEmoji} \`${dailyPnlSign}${dailyPnl.toFixed(2)}\` (\`${dailyPnlSign}${dailyPnlPercent.toFixed(2)}%\`)\n`;
        }
    }
    let pnl = capital > 0 ? total - capital : 0;
    let pnlPercent = capital > 0 ? (pnl / capital) * 100 : 0;
    let pnlEmoji = pnl >= 0 ? 'üü¢' : 'üî¥';
    let pnlSign = pnl >= 0 ? '+' : '';
    const usdtAsset = assets.find(a => a.asset === 'USDT');
    const usdtValue = usdtAsset ? usdtAsset.value : 0;
    const cashPercent = total > 0 ? (usdtValue / total) * 100 : 0;
    const investedPercent = 100 - cashPercent;
    const liquidityText = `   - *ÿßŸÑÿ≥ŸäŸàŸÑÿ©:* üíµ ÿßŸÑŸÉÿßÿ¥ ${cashPercent.toFixed(1)}% / üìà ÿßŸÑŸÖÿ≥ÿ™ÿ´ŸÖÿ± ${investedPercent.toFixed(1)}%`;
    let msg = `üßæ *ŸÖŸÑÿÆÿµ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä*\n\n`;
    msg += `*ÿ¢ÿÆÿ± ÿ™ÿ≠ÿØŸäÿ´ ŸÑŸÑÿ£ÿ≥ÿπÿßÿ±: ${new Date().toLocaleString("ar-EG", { timeZone: "Africa/Cairo" })}*\n`;
    msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    msg += `üìä *ÿßŸÑÿ£ÿØÿßÿ° ÿßŸÑÿπÿßŸÖ:*\n`;
    msg += `   üí∞ *ÿßŸÑŸÇŸäŸÖÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©:* \`$${total.toFixed(2)}\`\n`;
    msg += `   üíº *ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ:* \`$${capital.toFixed(2)}\`\n`;
    msg += `   üìâ *ÿ±ÿ®ÿ≠ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ∫Ÿäÿ± ŸÖÿ≠ŸÇŸÇ:* ${pnlEmoji} \`${pnlSign}${pnl.toFixed(2)}\` (\`${pnlSign}${pnlPercent.toFixed(2)}%\`)\n`;
    msg += dailyPnlText;
    msg += liquidityText + `\n`;
    msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
    msg += `üíé *ÿßŸÑÿ£ÿµŸÄŸÄŸÄŸÄŸÄŸÄŸÄŸÄŸàŸÑ:*\n`;
    assets.forEach((a, index) => {
        let percent = total > 0 ? ((a.value / total) * 100) : 0;
        msg += "\n";
        if (a.asset === "USDT") {
            msg += `*USDT* üíµ\n`;
            msg += `*ÿßŸÑÿ±ÿµŸäÿØ:* \`$${a.value.toFixed(2)}\` (\`${percent.toFixed(2)}%\`)`;
        } else {
            const change24hPercent = a.change24h * 100;
            const changeEmoji = change24hPercent >= 0 ? 'üü¢' : 'üî¥';
            const changeSign = change24hPercent >= 0 ? '+' : '';
            msg += `‚ï≠‚îÄ *${a.asset}*\n`;
            msg += `‚îú‚îÄ üí∞ *ÿßŸÑŸÇŸäŸÖÿ©:* \`$${a.value.toFixed(2)}\` (\`${percent.toFixed(2)}%\`)\n`;
            msg += `‚îú‚îÄ üìà *ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä:* \`$${a.price.toFixed(4)}\`\n`;
            msg += `‚îú‚îÄ ‚è±Ô∏è *ÿ™ÿ∫Ÿäÿ± (24ÿ≥):* ${changeEmoji} \`${changeSign}${change24hPercent.toFixed(2)}%\`\n`;
            if (positions[a.asset] && positions[a.asset].avgBuyPrice > 0) {
                const position = positions[a.asset];
                const avgBuyPrice = position.avgBuyPrice;
                const totalCost = avgBuyPrice * a.amount;
                const assetPnl = a.value - totalCost;
                const assetPnlPercent = (totalCost > 0) ? (assetPnl / totalCost) * 100 : 0;
                const assetPnlEmoji = assetPnl >= 0 ? 'üü¢' : 'üî¥';
                const assetPnlSign = assetPnl >= 0 ? '+' : '';
                msg += `‚îú‚îÄ üõí *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${avgBuyPrice.toFixed(4)}\`\n`;
                msg += `‚ï∞‚îÄ üìâ *ÿ±ÿ®ÿ≠ ÿ∫Ÿäÿ± ŸÖÿ≠ŸÇŸÇ:* ${assetPnlEmoji} \`${assetPnlSign}${assetPnl.toFixed(2)}\` (\`${assetPnlSign}${assetPnlPercent.toFixed(2)}%\`)`;
            } else {
                msg += `‚ï∞‚îÄ üõí *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑŸá`;
            }
        }
        if (index < assets.length - 1) {
            msg += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
        }
    });
    return msg;
}

async function monitorBalanceChanges() {
    try {
        await sendDebugMessage("ÿ®ÿØÿ° ÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµŸÅŸÇÿßÿ™...");
        let previousState = await loadBalanceState();
        let previousBalanceState = previousState.balances || {};
        let previousTotalPortfolioValue = previousState.totalValue || 0;
        const currentBalance = await getBalanceForComparison();

        if (!currentBalance) { await sendDebugMessage("ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑÿ≠ÿßŸÑŸä."); return; }
        
        const prices = await getMarketPrices();
        if (!prices) { await sendDebugMessage("ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ÿßŸÑÿ£ÿ≥ÿπÿßÿ±."); return; }

        const { total: newTotalPortfolioValue } = await getPortfolio(prices);
        if (newTotalPortfolioValue === undefined) { await sendDebugMessage("ŸÅÿ¥ŸÑ ÿ¨ŸÑÿ® ŸÇŸäŸÖÿ© ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©."); return; }

        if (Object.keys(previousBalanceState).length === 0) {
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
            await sendDebugMessage("ÿ™ŸÖ ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿ±ÿµŸäÿØ ÿßŸÑÿ£ŸàŸÑŸä Ÿàÿ≠ŸÅÿ∏Ÿá.");
            return;
        }
        
        const allAssets = new Set([...Object.keys(previousBalanceState), ...Object.keys(currentBalance)]);
        for (const asset of allAssets) {
            if (asset === 'USDT') continue;
            const prevAmount = previousBalanceState[asset] || 0;
            const currAmount = currentBalance[asset] || 0;
            const difference = currAmount - prevAmount;

            if (Math.abs(difference) < 1e-9) continue;
            
            const priceData = prices[`${asset}-USDT`];
            if (!priceData || !priceData.price) {
                await sendDebugMessage(`ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≥ÿπÿ± ŸÑŸÄ ${asset}. ÿ≥Ÿäÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ Ÿáÿ∞ÿß ÿßŸÑÿ™ÿ∫ŸäŸäÿ±.`);
                continue;
            }
            const price = priceData.price;
            
            const retrospectiveReport = await updatePositionAndAnalyze(asset, difference, price, currAmount);
            if (retrospectiveReport) {
                await bot.api.sendMessage(AUTHORIZED_USER_ID, retrospectiveReport, { parse_mode: "Markdown" });
            }

            // --- Re-integrated Channel Publishing Logic ---
            const tradeValue = Math.abs(difference) * price;
            const type = difference > 0 ? 'ÿ¥ÿ±ÿßÿ°' : 'ÿ®Ÿäÿπ';
            let publicRecommendationText = "";
            let callbackData = "";
            const newAssetValue = currAmount * price;
            const portfolioPercentage = newTotalPortfolioValue > 0 ? (newAssetValue / newTotalPortfolioValue) * 100 : 0;
            const timestamp = `*ÿ¢ÿÆÿ± ÿ™ÿ≠ÿØŸäÿ´: ${new Date().toLocaleDateString("en-GB").replace(/\//g,'.')}*`;

            if (type === 'ÿ¥ÿ±ÿßÿ°') {
                const entryOfPortfolio = previousTotalPortfolioValue > 0 ? (tradeValue / previousTotalPortfolioValue) * 100 : 0;
                const previousUSDTBalance = previousBalanceState['USDT'] || 0;
                const entryOfCash = previousUSDTBalance > 0 ? (tradeValue / previousUSDTBalance) * 100 : 0;
                publicRecommendationText = `üîî **ÿ™ŸàÿµŸäÿ© ÿ™ÿØÿßŸàŸÑ ÿ¨ÿØŸäÿØÿ© | ÿ¥ÿ±ÿßÿ°** üü¢\n\n` + `üî∏ **ÿßŸÑÿπŸÖŸÑÿ©:** \`${asset}/USDT\`\n\n` + `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµŸÅŸÇÿ©:**\n` + `   üí∞ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ≥ÿπÿ±:* \`$${price.toFixed(4)}\`\n` + `   üì¶ *ÿ≠ÿ¨ŸÖ ÿßŸÑÿØÿÆŸàŸÑ:* \`${entryOfPortfolio.toFixed(2)}%\`\n\n` + `üìä **ÿ™ÿ£ÿ´Ÿäÿ±Ÿáÿß ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` + `   üíµ *ÿßÿ≥ÿ™ŸáŸÑÿßŸÉ ÿßŸÑŸÉÿßÿ¥:* \`${entryOfCash.toFixed(2)}%\`\n` + `   üìà *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n\n${timestamp}`;
                callbackData = `publish_buy_${asset}_${price.toFixed(4)}_${entryOfPortfolio.toFixed(2)}_${entryOfCash.toFixed(2)}_${portfolioPercentage.toFixed(2)}`;
            } else { // Sell
                if (currAmount < 0.0001) { // Full close
                    publicRecommendationText = `üîî **ÿ™ŸàÿµŸäÿ© ÿ™ÿØÿßŸàŸÑ ÿ¨ÿØŸäÿØÿ© | ÿ•ÿ∫ŸÑÿßŸÇ ŸÖÿ±ŸÉÿ≤** üî¥\n\n` + `üî∏ **ÿßŸÑÿπŸÖŸÑÿ©:** \`${asset}/USDT\`\n\n` + `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµŸÅŸÇÿ©:**\n` + `   üí∞ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${price.toFixed(4)}\`\n` + `   ‚úÖ *ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:* ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑŸÖÿ±ŸÉÿ≤ ÿ®ÿßŸÑŸÉÿßŸÖŸÑ.\n\n` + `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` + `   üíµ *ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ©:* \`$${tradeValue.toFixed(2)}\` ÿ•ŸÑŸâ ÿßŸÑŸÉÿßÿ¥.\n` + `   üìà *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`0.00%\`\n\n${timestamp}`;
                    callbackData = `publish_close_${asset}_${price.toFixed(4)}_${tradeValue.toFixed(2)}`;
                } else { // Partial sell
                     publicRecommendationText = `üîî **ÿ™ÿ≠ÿØŸäÿ´ ÿ™ŸàÿµŸäÿ© | ÿ™ÿÆŸÅŸäŸÅ** üü†\n\n` + `üî∏ **ÿßŸÑÿπŸÖŸÑÿ©:** \`${asset}/USDT\`\n\n` + `üìù **ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµŸÅŸÇÿ©:**\n` + `   üí∞ *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${price.toFixed(4)}\`\n` + `   üìâ *ÿ™ŸÖ ÿ®Ÿäÿπ:* ÿ¨ÿ≤ÿ° ŸÖŸÜ ÿßŸÑŸÉŸÖŸäÿ©\n\n` + `üìä **ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:**\n` + `   üìà *ÿßŸÑŸàÿ≤ŸÜ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿπŸÖŸÑÿ©:* \`${portfolioPercentage.toFixed(2)}%\`\n\n${timestamp}`;
                     callbackData = `publish_sell_${asset}_${price.toFixed(4)}_${portfolioPercentage.toFixed(2)}`;
                }
            }
            const settings = await loadSettings();
            if (settings.autoPostToChannel && publicRecommendationText) {
                await bot.api.sendMessage(process.env.TARGET_CHANNEL_ID, publicRecommendationText, { parse_mode: "Markdown" });
            } else if (publicRecommendationText) {
                const confirmationKeyboard = new InlineKeyboard().text("‚úÖ ŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©", callbackData).text("‚ùå ÿ™ÿ¨ÿßŸáŸÑ", "ignore_trade");
                await bot.api.sendMessage(AUTHORIZED_USER_ID, `*ŸáŸÑ ÿ™ÿ±ŸäÿØ ŸÜÿ¥ÿ± ÿßŸÑÿ™ŸàÿµŸäÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ© ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©ÿü*\n\n${publicRecommendationText}`, { parse_mode: "Markdown", reply_markup: confirmationKeyboard });
            }
            // --- End of Publishing Logic ---
            
            await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
            await sendDebugMessage(`State updated after processing trade for ${asset}.`);
            return;
        }
        
        await sendDebugMessage("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ÿ∫ŸäŸäÿ±ÿßÿ™.");
        await saveBalanceState({ balances: currentBalance, totalValue: newTotalPortfolioValue });
    } catch (e) {
        console.error("CRITICAL ERROR in monitorBalanceChanges:", e);
    }
}

async function checkPriceAlerts() { try { const alerts = await loadAlerts(); if (alerts.length === 0) return; const prices = await getMarketPrices(); if (!prices) return; const remainingAlerts = []; let alertsTriggered = false; for (const alert of alerts) { const currentPrice = (prices[alert.instId] || {}).price; if (currentPrice === undefined) { remainingAlerts.push(alert); continue; } let triggered = false; if (alert.condition === '>' && currentPrice > alert.price) triggered = true; else if (alert.condition === '<' && currentPrice < alert.price) triggered = true; if (triggered) { const message = `üö® *ÿ™ŸÜÿ®ŸäŸá ÿ≥ÿπÿ±!* üö®\n\n- ÿßŸÑÿπŸÖŸÑÿ©: *${alert.instId}*\n- ÿßŸÑÿ¥ÿ±ÿ∑: ÿ™ÿ≠ŸÇŸÇ (${alert.condition} ${alert.price})\n- ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä: *${currentPrice}*`; await bot.api.sendMessage(AUTHORIZED_USER_ID, message, { parse_mode: "Markdown" }); alertsTriggered = true; } else { remainingAlerts.push(alert); } } if (alertsTriggered) { await saveAlerts(remainingAlerts); } } catch (error) { console.error("Error in checkPriceAlerts:", error); } }

async function runDailyJobs() {
    try {
        console.log("Attempting to run daily jobs...");
        const settings = await loadSettings();
        if (!settings.dailySummary) { console.log("Daily summary is disabled. Skipping."); return; }
        const prices = await getMarketPrices();
        if (!prices) { console.error("Daily Jobs: Failed to get prices."); return; }
        const { total, error } = await getPortfolio(prices);
        if (error) { console.error("Daily Jobs Error:", error); return; }
        const history = await loadHistory();
        const date = new Date().toISOString().slice(0, 10);
        const todayRecordIndex = history.findIndex(h => h.date === date);
        if (todayRecordIndex > -1) { history[todayRecordIndex].total = total; } 
        else { history.push({ date: date, total: total }); }
        if (history.length > 35) history.shift();
        await saveHistory(history);
        console.log(`[‚úÖ Daily Summary Recorded]: ${date} - $${total.toFixed(2)}`);
    } catch(e) { console.error("CRITICAL ERROR in runDailyJobs:", e); }
}

const mainKeyboard = new Keyboard()
    .text("üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").text("üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©").row()
    .text("‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©").text("üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá").row()
    .text("üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©").row()
    .text("‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™").resized();
    
async function sendSettingsMenu(ctx) { const settings = await loadSettings(); const settingsKeyboard = new InlineKeyboard().text("üí∞ ÿ™ÿπŸäŸäŸÜ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ", "set_capital").text("üíº ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ±ÿßŸÉÿ≤", "view_positions").row().text("üóëÔ∏è ÿ≠ÿ∞ŸÅ ÿ™ŸÜÿ®ŸäŸá ÿ≥ÿπÿ±", "delete_alert").text(`üì∞ ÿßŸÑŸÖŸÑÿÆÿµ ÿßŸÑŸäŸàŸÖŸä: ${settings.dailySummary ? '‚úÖ' : '‚ùå'}`, "toggle_summary").row().text(`üöÄ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä: ${settings.autoPostToChannel ? '‚úÖ' : '‚ùå'}`, "toggle_autopost").text(`üêû Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ¥ÿÆŸäÿµ: ${settings.debugMode ? '‚úÖ' : '‚ùå'}`, "toggle_debug").row().text("üî• ÿ≠ÿ∞ŸÅ ŸÉŸÑ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ üî•", "delete_all_data"); const text = "‚öôÔ∏è *ŸÑŸàÿ≠ÿ© ÿßŸÑÿ™ÿ≠ŸÉŸÖ ŸàÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©*"; try { await ctx.editMessageText(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard }); } catch { await ctx.reply(text, { parse_mode: "Markdown", reply_markup: settingsKeyboard }); } }

bot.use(async (ctx, next) => { if (ctx.from?.id === AUTHORIZED_USER_ID) { await next(); } else { console.log(`Unauthorized access attempt by user ID: ${ctx.from?.id}`); } });
bot.command("start", async (ctx) => { await ctx.reply(`ü§ñ *ÿ®Ÿàÿ™ OKX ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä ÿßŸÑŸÖÿ™ŸÉÿßŸÖŸÑ*\n*ÿßŸÑÿ•ÿµÿØÿßÿ±: v46 - Final Verified Complete*`, { parse_mode: "Markdown", reply_markup: mainKeyboard }); });
bot.command("settings", async (ctx) => await sendSettingsMenu(ctx));
bot.command("pnl", async (ctx) => { const args = ctx.match.trim().split(/\s+/); if (args.length !== 3 || args[0] === '') { return await ctx.reply(`‚ùå *ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©*\n\n` + `*Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÑŸÑÿ£ŸÖÿ±.*\n\n` + `*ŸÖÿ´ÿßŸÑ:*\n\`/pnl <ÿ¥ÿ±ÿßÿ°> <ÿ®Ÿäÿπ> <ŸÉŸÖŸäÿ©>\``, { parse_mode: "Markdown" }); } const [buyPrice, sellPrice, quantity] = args.map(parseFloat); if (isNaN(buyPrice) || isNaN(sellPrice) || isNaN(quantity) || buyPrice <= 0 || sellPrice <= 0 || quantity <= 0) { return await ctx.reply("‚ùå *ÿÆÿ∑ÿ£:* ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÇŸäŸÖ ÿ£ÿ±ŸÇÿßŸÖ ŸÖŸàÿ¨ÿ®ÿ©."); } const totalInvestment = buyPrice * quantity; const totalSaleValue = sellPrice * quantity; const profitOrLoss = totalSaleValue - totalInvestment; const pnlPercentage = (profitOrLoss / totalInvestment) * 100; const resultStatus = profitOrLoss >= 0 ? "ÿ±ÿ®ÿ≠ ‚úÖ" : "ÿÆÿ≥ÿßÿ±ÿ© üîª"; const pnlSign = profitOrLoss >= 0 ? '+' : ''; const responseMessage = `üßÆ *ŸÜÿ™Ÿäÿ¨ÿ© ÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©*\n\n` + `üìù **ÿßŸÑŸÖÿØÿÆŸÑÿßÿ™:**\n` + `   - *ÿ≥ÿπÿ± ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${buyPrice.toLocaleString()}\`\n` + `   - *ÿ≥ÿπÿ± ÿßŸÑÿ®Ÿäÿπ:* \`$${sellPrice.toLocaleString()}\`\n` + `   - *ÿßŸÑŸÉŸÖŸäÿ©:* \`${quantity.toLocaleString()}\`\n\n` + `üìä **ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨:**\n` + `   - *ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${totalInvestment.toLocaleString()}\`\n` + `   - *ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑÿ®Ÿäÿπ:* \`$${totalSaleValue.toLocaleString()}\`\n` + `   - *ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠:* \`${pnlSign}${profitOrLoss.toLocaleString()}\` (\`${pnlSign}${pnlPercentage.toFixed(2)}%\`)\n\n` + `**${resultStatus}**`; await ctx.reply(responseMessage, { parse_mode: "Markdown" }); });

bot.on("callback_query:data", async (ctx) => {
    const data = ctx.callbackQuery.data;
    await ctx.answerCallbackQuery();
    
    if (data.startsWith("chart_")) {
        const period = data.split('_')[1];
        await ctx.editMessageText("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ™ŸÇÿ±Ÿäÿ±...");
        let history, periodLabel, periodData;
        if (period === '24h') { history = await loadHourlyHistory(); periodLabel = "ÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©"; periodData = history.slice(-24); }
        else if (period === '7d') { history = await loadHistory(); periodLabel = "ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ"; periodData = history.slice(-7).map(h => ({ label: h.date.slice(5), total: h.total })); }
        else if (period === '30d') { history = await loadHistory(); periodLabel = "ÿ¢ÿÆÿ± 30 ŸäŸàŸÖŸãÿß"; periodData = history.slice(-30).map(h => ({ label: h.date.slice(5), total: h.total })); }
        const stats = calculatePerformanceStats(periodData);
        if (!stats) { await ctx.editMessageText("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÉÿßŸÅŸäÿ© ŸÑŸáÿ∞Ÿá ÿßŸÑŸÅÿ™ÿ±ÿ©."); return; }
        const chartUrl = createChartUrl(periodData, periodLabel);
        const pnlEmoji = stats.pnl >= 0 ? 'üü¢' : 'üî¥';
        const pnlSign = stats.pnl >= 0 ? '+' : '';
        const caption = `üìä *ÿ™ÿ≠ŸÑŸäŸÑ ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ© | ${periodLabel}*\n\n` + `üìà **ÿßŸÑŸÜÿ™Ÿäÿ¨ÿ©:** ${pnlEmoji} \`${pnlSign}$${stats.pnl.toFixed(2)}\` (\`${pnlSign}${stats.pnlPercent.toFixed(2)}%\`)\n` + `*ÿßŸÑÿ™ÿ∫Ÿäÿ± ÿßŸÑÿµÿßŸÅŸä: ŸÖŸÜ \`$${stats.startValue.toFixed(2)}\` ÿ•ŸÑŸâ \`$${stats.endValue.toFixed(2)}\`*\n\n` + `üìù **ŸÖŸÑÿÆÿµ ÿßŸÑŸÅÿ™ÿ±ÿ©:**\n` + `   ‚¨ÜÔ∏è *ÿ£ÿπŸÑŸâ ŸÇŸäŸÖÿ©:* \`$${stats.maxValue.toFixed(2)}\`\n` + `   ‚¨áÔ∏è *ÿ£ÿØŸÜŸâ ŸÇŸäŸÖÿ©:* \`$${stats.minValue.toFixed(2)}\`\n` + `   üìä *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑŸÇŸäŸÖÿ©:* \`$${stats.avgValue.toFixed(2)}\`\n\n`+ `*ÿßŸÑÿ™ŸÇÿ±Ÿäÿ± ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ§Ÿá ŸÅŸä: ${new Date().toLocaleDateString("en-GB").replace(/\//g,'.')}*`;
        try { await ctx.replyWithPhoto(chartUrl, { caption: caption, parse_mode: "Markdown" }); await ctx.deleteMessage(); } catch(e) { console.error("Failed to send chart:", e); await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ±ÿ≥ŸÖ ÿßŸÑÿ®ŸäÿßŸÜŸä."); }
        return;
    }
    
    if (data.startsWith("publish_")) {
        const [, type, asset, ...params] = data.split('_');
        let finalRecommendation = ctx.callbackQuery.message.text.replace("*ŸáŸÑ ÿ™ÿ±ŸäÿØ ŸÜÿ¥ÿ± ÿßŸÑÿ™ŸàÿµŸäÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ© ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©ÿü*\n\n", "");
        try {
            await bot.api.sendMessage(process.env.TARGET_CHANNEL_ID, finalRecommendation, { parse_mode: "Markdown" });
            await ctx.editMessageText("‚úÖ ÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠.", { reply_markup: undefined });
        } catch (e) {
            console.error("Failed to post to channel:", e);
            await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©.", { reply_markup: undefined });
        }
        return;
    }
    if (data === "ignore_trade") {
        await ctx.editMessageText("‚ùå ÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿµŸÅŸÇÿ©.", { reply_markup: undefined });
        return;
    }

    switch (data) {
        case "view_positions":
            const positions = await loadPositions();
            if (Object.keys(positions).length === 0) { await ctx.reply("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÖÿ±ÿßŸÉÿ≤ ŸÖŸÅÿ™Ÿàÿ≠ÿ© Ÿäÿ™ÿ™ÿ®ÿπŸáÿß ÿßŸÑÿ®Ÿàÿ™ ÿ≠ÿßŸÑŸäŸãÿß."); } else {
                let msg = "üìÑ *ÿßŸÑŸÖÿ±ÿßŸÉÿ≤ ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ÿ© ÿßŸÑÿ™Ÿä Ÿäÿ™ŸÖ ÿ™ÿ™ÿ®ÿπŸáÿß ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß:*\n";
                for (const symbol in positions) {
                    const pos = positions[symbol];
                    msg += `\n‚ï≠‚îÄ *${symbol}*`;
                    msg += `\n‚îú‚îÄ üõí *ŸÖÿ™Ÿàÿ≥ÿ∑ ÿßŸÑÿ¥ÿ±ÿßÿ°:* \`$${pos.avgBuyPrice.toFixed(4)}\``;
                    msg += `\n‚îú‚îÄ üì¶ *ÿßŸÑŸÉŸÖŸäÿ© ÿßŸÑŸÖÿ¥ÿ™ÿ±ÿßÿ©:* \`${pos.totalAmountBought.toFixed(6)}\``;
                    msg += `\n‚ï∞‚îÄ üóìÔ∏è *ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÅÿ™ÿ≠:* \`${new Date(pos.openDate).toLocaleDateString('en-GB')}\``;
                }
                await ctx.reply(msg, { parse_mode: "Markdown" });
            }
            break;
        case "set_capital": waitingState = 'set_capital'; await ctx.reply("üí∞ ÿ£ÿ±ÿ≥ŸÑ ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ."); break;
        case "delete_alert":
            const alerts = await loadAlerts();
            if (alerts.length === 0) {
                await ctx.reply("‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿ≥ÿπÿ± ŸÖÿ≥ÿ¨ŸÑÿ© ŸÑÿ≠ÿ∞ŸÅŸáÿß.");
            } else {
                let msg = "üóëÔ∏è *ÿßŸÑÿ™ŸÜÿ®ŸäŸáÿßÿ™ ÿßŸÑŸÖÿ≥ÿ¨ŸÑÿ©:*\n\n";
                alerts.forEach((alert, index) => {
                    msg += `*${index + 1}.* \`${alert.instId}\` ${alert.condition} \`${alert.price}\`\n`;
                });
                msg += "\n*ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÇŸÖ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿ≠ÿ∞ŸÅŸá.*";
                waitingState = 'delete_alert_number';
                await ctx.reply(msg, { parse_mode: "Markdown" });
            }
            break;
        case "toggle_summary": case "toggle_autopost": case "toggle_debug": { let settings = await loadSettings(); if (data === 'toggle_summary') settings.dailySummary = !settings.dailySummary; else if (data === 'toggle_autopost') settings.autoPostToChannel = !settings.autoPostToChannel; else if (data === 'toggle_debug') settings.debugMode = !settings.debugMode; await saveSettings(settings); await sendSettingsMenu(ctx); } break;
        case "delete_all_data": waitingState = 'confirm_delete_all'; await ctx.reply("‚ö†Ô∏è *ŸáŸÑ ÿ£ŸÜÿ™ ŸÖÿ™ÿ£ŸÉÿØÿü*\nÿ£ÿ±ÿ≥ŸÑ `ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ` ŸÑŸÑŸÖÿ™ÿßÿ®ÿπÿ©.", { parse_mode: "Markdown" }); setTimeout(() => { if (waitingState === 'confirm_delete_all') waitingState = null; }, 30000); break;
    }
});

bot.on("message:text", async (ctx) => {
    const text = ctx.message.text.trim();
    if (ctx.message.text && ctx.message.text.startsWith('/')) { return; }
    
    // Main menu handlers
    switch(text) {
        case "üìä ÿπÿ±ÿ∂ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
            await ctx.reply("‚è≥ ÿ¨ÿßÿ±Ÿä ÿ¨ŸÑÿ® ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©...");
            const pricesPortfolio = await getMarketPrices();
            if (!pricesPortfolio) { return await ctx.reply("‚ùå ŸÅÿ¥ŸÑ ŸÅŸä ÿ¨ŸÑÿ® ÿ£ÿ≥ÿπÿßÿ± ÿßŸÑÿ≥ŸàŸÇ."); }
            const capital = await loadCapital();
            const { assets, total, error } = await getPortfolio(pricesPortfolio);
            if (error) { return await ctx.reply(`‚ùå ${error}`); }
            const msgPortfolio = await formatPortfolioMsg(assets, total, capital);
            await ctx.reply(msgPortfolio, { parse_mode: "Markdown" });
            return;
        case "üìà ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©":
            const performanceKeyboard = new InlineKeyboard().text("ÿ¢ÿÆÿ± 24 ÿ≥ÿßÿπÿ©", "chart_24h").row().text("ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ", "chart_7d").row().text("ÿ¢ÿÆÿ± 30 ŸäŸàŸÖŸãÿß", "chart_30d");
            await ctx.reply("ÿßÿÆÿ™ÿ± ÿßŸÑŸÅÿ™ÿ±ÿ© ÿßŸÑÿ≤ŸÖŸÜŸäÿ© ŸÑÿπÿ±ÿ∂ ÿ£ÿØÿßÿ° ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:", { reply_markup: performanceKeyboard });
            return;
        case "‚ÑπÔ∏è ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ©":
            waitingState = 'coin_info';
            await ctx.reply("‚úçÔ∏è ÿ£ÿ±ÿ≥ŸÑ ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ© (ŸÖÿ´ÿßŸÑ: `BTC-USDT`)");
            return;
        case "‚öôÔ∏è ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™":
            await sendSettingsMenu(ctx);
            return;
        case "üîî ÿ∂ÿ®ÿ∑ ÿ™ŸÜÿ®ŸäŸá":
            waitingState = 'set_alert';
            await ctx.reply("‚úçÔ∏è *ÿ£ÿ±ÿ≥ŸÑ ÿ™ŸÜÿ®ŸäŸá ÿßŸÑÿ≥ÿπÿ± ÿ®ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑÿ™ÿßŸÑŸäÿ©:*\n`<ÿ±ŸÖÿ≤ ÿßŸÑÿπŸÖŸÑÿ©> < > ÿ£Ÿà < > <ÿßŸÑÿ≥ÿπÿ±>`\n\n*ÿ£ŸÖÿ´ŸÑÿ©:*\n`BTC-USDT > 70000`\n`ETH-USDT < 3500`", { parse_mode: "Markdown" });
            return;
        case "üßÆ ÿ≠ÿßÿ≥ÿ®ÿ© ÿßŸÑÿ±ÿ®ÿ≠ ŸàÿßŸÑÿÆÿ≥ÿßÿ±ÿ©":
             await ctx.reply("‚úçÔ∏è ŸÑÿ≠ÿ≥ÿßÿ® ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©ÿå ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿ£ŸÖÿ± `/pnl`.\n\n*ŸÖÿ´ÿßŸÑ:*\n`/pnl 50000 60000 0.5`", { parse_mode: "Markdown" });
             return;
    }

    if (waitingState) {
        const state = waitingState;
        waitingState = null;
        switch (state) {
            case 'set_capital': const amount = parseFloat(text); if (!isNaN(amount) && amount >= 0) { await saveCapital(amount); await ctx.reply(`‚úÖ *ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿ±ÿ£ÿ≥ ÿßŸÑŸÖÿßŸÑ*\n\nüí∞ **ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑÿ¨ÿØŸäÿØ:** \`$${amount.toFixed(2)}\``, {parse_mode: "Markdown"}); } else { await ctx.reply("‚ùå ŸÖÿ®ŸÑÿ∫ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠."); } return;
            case 'coin_info':
                const instId = text.toUpperCase();
                await ctx.reply(`‚è≥ ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ®ÿ≠ÿ´ ÿπŸÜ ŸÖÿπŸÑŸàŸÖÿßÿ™ ${instId}...`);
                const details = await getInstrumentDetails(instId);
                if (details.error) { return await ctx.reply(`‚ùå ${details.error}`); }
                
                let msg = `‚ÑπÔ∏è *ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿπŸÖŸÑÿ© | ${instId}*\n\n` + `   üí≤ *ÿßŸÑÿ≥ÿπÿ± ÿßŸÑÿ≠ÿßŸÑŸä:* \`$${details.price.toFixed(4)}\`\n` + `   üìà *ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ± (24ÿ≥):* \`$${details.high24h.toFixed(4)}\`\n` + `   üìâ *ÿ£ÿØŸÜŸâ ÿ≥ÿπÿ± (24ÿ≥):* \`$${details.low24h.toFixed(4)}\`\n\n` + `   üìÖ *ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑÿ£ÿ≥ÿ®ŸàÿπŸä (ÿ¢ÿÆÿ± 7 ÿ£ŸäÿßŸÖ):*\n` + `   ‚¨ÜÔ∏è *ÿ£ÿπŸÑŸâ ÿ≥ÿπÿ±:* \`$${details.weeklyHigh.toFixed(4)}\`\n` + `   ‚¨áÔ∏è *ÿ£ÿØŸÜŸâ ÿ≥ÿπÿ±:* \`$${details.weeklyLow.toFixed(4)}\`\n\n` + `   üìä *ÿ≠ÿ¨ŸÖ ÿßŸÑÿ™ÿØÿßŸàŸÑ (24ÿ≥):* \`$${details.vol24h.toLocaleString()}\`\n\n` + `*ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ŸÖŸÜ ŸÖŸÜÿµÿ© OKX*`;
                
                const prices = await getMarketPrices();
                if (prices) {
                    const { assets: userAssets } = await getPortfolio(prices);
                    const coinSymbol = instId.split('-')[0];
                    const ownedAsset = userAssets.find(a => a.asset === coinSymbol);
                    const positions = await loadPositions();
                    const assetPosition = positions[coinSymbol];
        
                    if (ownedAsset && assetPosition) {
                        const amount = ownedAsset.amount;
                        const avgBuyPrice = assetPosition.avgBuyPrice;
                        const totalCost = avgBuyPrice * amount;
                        const totalPnl = (details.price * amount) - totalCost;
                        const totalPnlPercent = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
                        const totalPnlEmoji = totalPnl >= 0 ? 'üü¢' : 'üî¥';
                        const totalPnlSign = totalPnl >= 0 ? '+' : '';
        
                        const dailyPnl = (details.price - details.open24h) * amount;
                        const dailyPnlEmoji = dailyPnl >= 0 ? 'üü¢' : 'üî¥';
                        const dailyPnlSign = dailyPnl >= 0 ? '+' : '';
        
                        msg += `\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` + `üìä *ŸÖŸàŸÇŸÅŸÉ ŸÅŸä ÿßŸÑÿπŸÖŸÑÿ©:*\n` + `   - *ÿ±ÿ®ÿ≠ ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ∫Ÿäÿ± ŸÖÿ≠ŸÇŸÇ:* ${totalPnlEmoji} \`${totalPnlSign}${totalPnl.toFixed(2)}\` (\`${totalPnlSign}${totalPnlPercent.toFixed(2)}%\`)\n` + `   - *ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ© (ÿ¢ÿÆÿ± 24ÿ≥):* ${dailyPnlEmoji} \`${dailyPnlSign}${dailyPnl.toFixed(2)}\``;
                    }
                }
                await ctx.reply(msg, { parse_mode: "Markdown" });
                return;
            case 'set_alert':
                const parts = text.trim().split(/\s+/);
                if (parts.length !== 3) { return await ctx.reply("‚ùå ÿµŸäÿ∫ÿ© ÿ∫Ÿäÿ± ÿµÿ≠Ÿäÿ≠ÿ©. Ÿäÿ±ÿ¨Ÿâ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿµŸäÿ∫ÿ©: `SYMBOL > PRICE`"); }
                const [alertInstId, condition, priceStr] = parts;
                if (condition !== '>' && condition !== '<') { return await ctx.reply("‚ùå ÿßŸÑÿ¥ÿ±ÿ∑ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. ÿßÿ≥ÿ™ÿÆÿØŸÖ `>` ÿ£Ÿà `<` ŸÅŸÇÿ∑."); }
                const alertPrice = parseFloat(priceStr);
                if (isNaN(alertPrice) || alertPrice <= 0) { return await ctx.reply("‚ùå ÿßŸÑÿ≥ÿπÿ± ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠."); }
                const alertsList = await loadAlerts();
                alertsList.push({ instId: alertInstId.toUpperCase(), condition: condition, price: alertPrice });
                await saveAlerts(alertsList);
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ∂ÿ®ÿ∑ ÿßŸÑÿ™ŸÜÿ®ŸäŸá:\n*${alertInstId.toUpperCase()}* ÿ≥Ÿäÿ™ŸÖ ÿ™ŸÜÿ®ŸäŸáŸÉ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑÿ≥ÿπÿ± ${condition} *${alertPrice}*`, { parse_mode: "Markdown" });
                return;
            case 'delete_alert_number':
                const alertIndex = parseInt(text) - 1;
                let currentAlerts = await loadAlerts();
                if (isNaN(alertIndex) || alertIndex < 0 || alertIndex >= currentAlerts.length) {
                    return await ctx.reply("‚ùå ÿ±ŸÇŸÖ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßŸÑÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÜ ÿßŸÑŸÇÿßÿ¶ŸÖÿ©.");
                }
                const removedAlert = currentAlerts.splice(alertIndex, 1)[0];
                await saveAlerts(currentAlerts);
                await ctx.reply(`‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑÿ™ŸÜÿ®ŸäŸá ÿ®ŸÜÿ¨ÿßÿ≠:\n\`${removedAlert.instId} ${removedAlert.condition} ${removedAlert.price}\``, { parse_mode: "Markdown" });
                return;
            case 'confirm_delete_all': if (text === 'ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿ≠ÿ∞ŸÅ') { await getCollection("configs").deleteMany({}); await ctx.reply("‚úÖ ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠."); } else { await ctx.reply("‚ùå ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿπŸÖŸÑŸäÿ© ÿßŸÑÿ≠ÿ∞ŸÅ."); } return;
        }
    }
});

// Start the bot
async function startBot() {
    await connectDB();
    console.log("Database connected!");

    if (process.env.NODE_ENV === "production") {
        app.use(express.json());
        app.use(webhookCallback(bot, "express"));
        app.listen(PORT, () => {
            console.log(`Bot v46 (Final Verified Complete) listening on port ${PORT}`);
        });
    } else {
        bot.start();
        console.log("Bot v46 (Final Verified Complete) started with polling.");
    }

    // Set interval timers for recurring tasks
    setInterval(monitorBalanceChanges, 60000); // Check every 60 seconds
    setInterval(checkPriceAlerts, 30000);      // Check every 30 seconds
    setInterval(runDailyJobs, 3600000);        // Check every hour for daily job
}

startBot();
