// =================================================================
// OKX Advanced Analytics Bot - index.js (Final v62, Stable on Railway)
// =================================================================

const express = require("express");
const { Bot, Keyboard, InlineKeyboard } = require("grammy");
const fetch = require("node-fetch");
const crypto = require("crypto");
require("dotenv").config();
const { connectDB, getDB } = require("./database.js");

// --- Configuration ---
const app = express();
const bot = new Bot(process.env.TELEGRAM_BOT_TOKEN);
const PORT = process.env.PORT || 3000;
const AUTHORIZED_USER_ID = parseInt(process.env.AUTHORIZED_USER_ID, 10);
const TARGET_CHANNEL_ID = process.env.TARGET_CHANNEL_ID;
const API_BASE_URL = "https://www.okx.com";

// --- State ---
let waitingState = null;

// ========== Database Helpers ==========
const getCollection = (name) => getDB().collection("configs");

async function getConfig(id, defaultValue = {}) {
  try {
    const doc = await getCollection("configs").findOne({ _id: id });
    return doc ? doc.data : defaultValue;
  } catch {
    return defaultValue;
  }
}

async function saveConfig(id, data) {
  try {
    await getCollection("configs").updateOne({ _id: id }, { $set: { data } }, { upsert: true });
  } catch {}
}

const loadSettings = () => getConfig("settings", { autoPostToChannel: false, debugMode: false });
const saveSettings = (settings) => saveConfig("settings", settings);
const loadBalanceState = () => getConfig("balanceState", {});
const saveBalanceState = (state) => saveConfig("balanceState", state);
// (ÿ®ŸÇŸäÿ© ÿØŸàÿßŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸàÿßŸÑÿ≠ŸÅÿ∏ ŸÉŸÖÿß ŸáŸä)
const loadPositions = () => getConfig("positions", {});
const savePositions = (p) => saveConfig("positions", p);

// ========== OKX API & Helpers ==========
function getHeaders(method, path, body = "") {
  const timestamp = new Date().toISOString();
  const prehash = timestamp + method.toUpperCase() + path + (typeof body === 'object' ? JSON.stringify(body) : body);
  const sign = crypto.createHmac("sha256", process.env.OKX_API_SECRET_KEY).update(prehash).digest("base64");
  return {
    "OK-ACCESS-KEY": process.env.OKX_API_KEY, "OK-ACCESS-SIGN": sign,
    "OK-ACCESS-TIMESTAMP": timestamp, "OK-ACCESS-PASSPHRASE": process.env.OKX_API_PASSPHRASE,
    "Content-Type": "application/json",
  };
}

async function getMarketPrices() {
  try {
    const res = await fetch(`${API_BASE_URL}/api/v5/market/tickers?instType=SPOT`);
    const json = await res.json();
    if (json.code !== "0") return null;
    return json.data.reduce((acc, t) => {
      acc[t.instId] = { price: parseFloat(t.last), change24h: parseFloat(t.open24h) > 0 ? (parseFloat(t.last) - parseFloat(t.open24h)) / parseFloat(t.open24h) : 0 };
      return acc;
    }, {});
  } catch { return null; }
}

async function getBalanceForComparison() {
  try {
    const res = await fetch(`${API_BASE_URL}/api/v5/account/balance`, { headers: getHeaders("GET", "/api/v5/account/balance") });
    const json = await res.json();
    if (json.code !== '0' || !json.data[0]?.details) return null;
    return json.data[0].details.reduce((map, asset) => {
      map[asset.ccy] = parseFloat(asset.eq);
      return map;
    }, {});
  } catch { return null; }
}

async function updatePositionAndAnalyze(asset, diff, price, newAmt) {
    if (!price || isNaN(price)) return null;
    const positions = await loadPositions();
    const p = positions[asset];
    const tradeValue = Math.abs(diff) * price;
    let report = null;

    if (diff > 0) { // Buy
        if (!p) {
            positions[asset] = { totalBought: diff, totalCost: tradeValue, avgBuy: price, openDate: new Date().toISOString(), realizedValue: 0, totalSold: 0 };
        } else {
            p.totalBought += diff;
            p.totalCost += tradeValue;
            p.avgBuy = p.totalCost / p.totalBought;
        }
    } else if (p) { // Sell
        p.realizedValue += tradeValue;
        p.totalSold += Math.abs(diff);
        if (newAmt * price < 1) { // Closing position
            const pnl = p.realizedValue - p.totalCost;
            const pnlPct = p.totalCost > 0 ? (pnl / p.totalCost) * 100 : 0;
            const sign = pnl >= 0 ? "+" : "";
            report =
                `üîî **ÿ™ŸÇÿ±Ÿäÿ± ÿ•ÿ∫ŸÑÿßŸÇ ÿµŸÅŸÇÿ©**\n` +
                `*ÿßŸÑÿ£ÿµŸÑ:* ${asset}/USDT ${pnl >= 0 ? "üü¢" : "üî¥"}\n` +
                `*ÿµÿßŸÅŸä ÿßŸÑÿ±ÿ®ÿ≠/ÿßŸÑÿÆÿ≥ÿßÿ±ÿ©:* \`${sign}${pnl.toFixed(2)}\` (\`${sign}${pnlPct.toFixed(2)}%\`)\n`;
            delete positions[asset];
        }
    }
    await savePositions(positions);
    return report;
}


async function monitorBalanceChanges() {
    try {
        const prevState = await loadBalanceState();
        const prevBal = prevState.balances || {};
        const prevVal = prevState.totalValue || 0;

        const currentBal = await getBalanceForComparison();
        if (!currentBal) return;

        const prices = await getMarketPrices();
        if (!prices) return;

        // Note: Using a simplified total value calculation here for trade detection logic.
        // A full portfolio calculation might be needed for more detailed reports.
        const currentTotalValue = Object.entries(currentBal).reduce((sum, [ccy, amt]) => {
            const price = prices[`${ccy}-USDT`] ? prices[`${ccy}-USDT`].price : (ccy === 'USDT' ? 1 : 0);
            return sum + (amt * price);
        }, 0);


        if (Object.keys(prevBal).length === 0) {
            await saveBalanceState({ balances: currentBal, totalValue: currentTotalValue });
            return;
        }

        let tradesDetected = false;
        for (const asset of new Set([...Object.keys(prevBal), ...Object.keys(currentBal)])) {
            if (asset === "USDT") continue;

            const diff = (currentBal[asset] || 0) - (prevBal[asset] || 0);
            const priceData = prices[`${asset}-USDT`];
            if (!priceData || !priceData.price) continue;

            const tradeValue = Math.abs(diff) * priceData.price;
            if (tradeValue < 0.1) continue;

            tradesDetected = true;
            const price = priceData.price;

            const positionReport = await updatePositionAndAnalyze(asset, diff, price, currentBal[asset] || 0);
            if (positionReport) {
                await bot.api.sendMessage(AUTHORIZED_USER_ID, positionReport, { parse_mode: "Markdown" });
            }

            const tradeType = diff > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢‚¨ÜÔ∏è" : (currentBal[asset] * price < 1 ? "ÿ•ÿ∫ŸÑÿßŸÇ üî¥‚¨áÔ∏è" : "ÿ®Ÿäÿπ ÿ¨ÿ≤ÿ¶Ÿä üü†");
            const newAssetValue = (currentBal[asset] || 0) * price;
            const portPct = currentTotalValue > 0 ? (newAssetValue / currentTotalValue) * 100 : 0;
            const cashValue = currentBal['USDT'] || 0;
            const cashPct = currentTotalValue > 0 ? (cashValue / currentTotalValue) * 100 : 0;
            const entryPct = prevVal > 0 ? (tradeValue / prevVal) * 100 : 0;

            const privateText =
                `üîî **ÿ™ÿ≠ŸÑŸäŸÑ ÿ≠ÿ±ŸÉÿ© ÿ™ÿØÿßŸàŸÑ**\n` +
                `*ÿßŸÑÿπŸÖŸÑŸäÿ©:* ${tradeType}\n` +
                `*ÿßŸÑÿ£ÿµŸÑ:* \`${asset}/USDT\`\n\n` +
                `*ÿ≥ÿπÿ± ÿßŸÑÿ™ŸÜŸÅŸäÿ∞:* \`$${price.toFixed(4)}\`\n` +
                `*ÿßŸÑŸÉŸÖŸäÿ©:* \`${Math.abs(diff).toFixed(6)}\`\n` +
                `*ŸÇŸäŸÖÿ© ÿßŸÑÿµŸÅŸÇÿ©:* \`$${tradeValue.toFixed(2)}\`\n\n` +
                `*ÿßŸÑÿ™ÿ£ÿ´Ÿäÿ± ÿπŸÑŸâ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:*\n` +
                ` ‚ñ´Ô∏è ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸÅŸÇÿ©: \`${entryPct.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è Ÿàÿ≤ŸÜ ÿßŸÑÿπŸÖŸÑÿ© ÿßŸÑÿ¨ÿØŸäÿØ: \`${portPct.toFixed(2)}%\`\n` +
                ` ‚ñ´Ô∏è ŸÜÿ≥ÿ®ÿ© ÿßŸÑŸÉÿßÿ¥ ÿßŸÑÿ¨ÿØŸäÿØÿ©: \`${cashPct.toFixed(2)}%\`\n`;

            const settings = await loadSettings();
            if (settings.autoPostToChannel) {
                const channelText =
                    `üîî **ÿ™ŸàÿµŸäÿ© ÿ¨ÿØŸäÿØÿ©: ${diff > 0 ? "ÿ¥ÿ±ÿßÿ° üü¢" : "ÿ®Ÿäÿπ üî¥"}**\n\n` +
                    `*ÿßŸÑÿπŸÖŸÑÿ©:* \`${asset}/USDT\`\n` +
                    `*ÿ≥ÿπÿ± ÿßŸÑÿØÿÆŸàŸÑ ÿßŸÑŸÖŸÇÿ™ÿ±ÿ≠:* ~\`$${price.toFixed(4)}\`\n` +
                    `*ÿ≠ÿ¨ŸÖ ÿßŸÑÿØÿÆŸàŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≠ŸÅÿ∏ÿ©:* \`${entryPct.toFixed(2)}%\``;
                try {
                    await bot.api.sendMessage(TARGET_CHANNEL_ID, channelText, { parse_mode: "Markdown" });
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, privateText, { parse_mode: "Markdown" });
                } catch (e) {
                    await bot.api.sendMessage(AUTHORIZED_USER_ID, "‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ± ÿßŸÑÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÑŸÑŸÇŸÜÿßÿ©.");
                }
            } else {
                const kb = new InlineKeyboard().text("‚úÖ ŸÜÿ¥ÿ± ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©", "publish_trade").text("‚ùå ÿ™ÿ¨ÿßŸáŸÑ", "ignore_trade");
                await bot.api.sendMessage(AUTHORIZED_USER_ID, `*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n${privateText}`, { parse_mode: "Markdown", reply_markup: kb });
            }
        }

        if (tradesDetected) {
            await saveBalanceState({ balances: currentBal, totalValue: currentTotalValue });
        }
    } catch (e) {
        console.error("Error in monitorBalanceChanges:", e);
    }
}


// ========== Express Server & Bot Start ==========

// **ÿßŸÑÿ≠ŸÑ ŸáŸÜÿß**: ÿ™ÿπÿ±ŸäŸÅ ŸÖÿπÿßŸÑÿ¨ ŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ© ŸÇÿ®ŸÑ ÿ£Ÿä middleware ÿÆÿßÿµ ÿ®ÿßŸÑÿ®Ÿàÿ™
app.use(express.json());
app.get("/healthcheck", (req, res) => {
    res.status(200).send("OK");
});


// ÿ™ÿ∑ÿ®ŸäŸÇ Middleware ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸáŸàŸäÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿπŸÑŸâ ÿ¨ŸÖŸäÿπ ÿßŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿßŸÑÿ£ÿÆÿ±Ÿâ
bot.use(async (ctx, next) => {
    if (ctx.from?.id === AUTHORIZED_USER_ID) {
        await next();
    } else {
        // ŸÑÿß ÿ™ŸÅÿπŸÑ ÿ¥Ÿäÿ¶Ÿãÿß ŸÑŸÑÿ∑ŸÑÿ®ÿßÿ™ ÿ∫Ÿäÿ± ÿßŸÑŸÖÿµÿ±ÿ≠ ÿ®Ÿáÿß ŸÑÿ™ÿ¨ŸÜÿ® ÿ£Ÿä ŸÖÿ¥ÿßŸÉŸÑ
    }
});

// (ŸáŸÜÿß ÿ®ŸÇŸäÿ© ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ®Ÿàÿ™ ŸÖÿ´ŸÑ /start, /settings ŸàŸÖÿπÿßŸÑÿ¨ÿßÿ™ callback_query)
bot.command("start", (ctx) => {
    ctx.reply("ü§ñ ÿ®Ÿàÿ™ OKX ÿßŸÑÿ™ÿ≠ŸÑŸäŸÑŸä v62 ŸäÿπŸÖŸÑ ÿßŸÑÿ¢ŸÜ!");
});

bot.on("callback_query:data", async (ctx) => {
    const data = ctx.callbackQuery.data;
    if (data === "publish_trade") {
        const textToPublish = ctx.callbackQuery.message.text.replace("*ÿ™ŸÖ ÿßŸÉÿ™ÿ¥ÿßŸÅ ÿµŸÅŸÇÿ© ÿ¨ÿØŸäÿØÿ©ÿå ŸáŸÑ ÿ™ŸàÿØ ŸÜÿ¥ÿ±Ÿáÿßÿü*\n\n", "");
        try {
            await bot.api.sendMessage(TARGET_CHANNEL_ID, textToPublish, { parse_mode: "Markdown" });
            await ctx.editMessageText("‚úÖ ÿ™ŸÖ ÿßŸÑŸÜÿ¥ÿ± ÿ®ŸÜÿ¨ÿßÿ≠.");
        } catch {
            await ctx.editMessageText("‚ùå ŸÅÿ¥ŸÑ ÿßŸÑŸÜÿ¥ÿ±.");
        }
    } else if (data === "ignore_trade") {
        await ctx.editMessageText("‚ùå ÿ™ŸÖ ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿµŸÅŸÇÿ©.");
    }
});


async function startBot() {
    console.log("‚ñ∂Ô∏è ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™...");
    try {
        await connectDB();
        console.log("‚úÖ ÿ™ŸÖ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠.");

        // ÿ¨ÿØŸàŸÑÿ© ÿßŸÑŸÖŸáÿßŸÖ
        setInterval(monitorBalanceChanges, 60000); // 60 ÿ´ÿßŸÜŸäÿ©
        console.log("‚úÖ ÿ™ŸÖ ÿ¨ÿØŸàŸÑÿ© ŸÖŸáŸÖÿ© ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿµŸÅŸÇÿßÿ™.");

        // ÿ®ÿØÿ° ÿßŸÑÿ®Ÿàÿ™ ÿ®Ÿàÿ∂ÿπŸäÿ© Polling
        await bot.start();
        console.log("ü§ñ ÿßŸÑÿ®Ÿàÿ™ ÿ®ÿØÿ£ ŸàŸäÿπŸÖŸÑ ŸÅŸä Ÿàÿ∂ÿπŸäÿ© Polling.");

        // ÿ®ÿØÿ° ÿßŸÑÿÆÿßÿØŸÖ ŸÑŸÑÿ±ÿØ ÿπŸÑŸâ ŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ©
        app.listen(PORT, () => {
            console.log(`üåê ÿßŸÑÿÆÿßÿØŸÖ Ÿäÿ≥ÿ™ŸÖÿπ ÿπŸÑŸâ ÿßŸÑŸÖŸÜŸÅÿ∞ ${PORT} Ÿàÿ¨ÿßŸáÿ≤ ŸÑŸÅÿ≠ÿµ ÿßŸÑÿµÿ≠ÿ©.`);
        });

    } catch (e) {
        console.error("‚ùå ŸÅÿ¥ŸÑ ÿ≠ÿßÿØ ŸÅŸä ÿ®ÿØÿ° ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™:", e);
        process.exit(1); // ÿ•ŸÜŸáÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÅŸä ÿ≠ÿßŸÑÿ© ÿßŸÑŸÅÿ¥ŸÑ ÿßŸÑÿ≠ÿßÿØ
    }
}

// ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ®Ÿàÿ™
startBot();

